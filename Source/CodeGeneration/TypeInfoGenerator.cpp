#include "TypeInfoGenerator.hpp"

#include <spdlog/fmt/fmt.h>

#include <sstream>

namespace Ilum
{
inline void GenerateAttribute(std::stringstream &sstream, const std::vector<Meta::Attribute> &attributes)
{
	if (!attributes.empty())
	{
		sstream << "(" << std::endl;
		for (auto &attribute : attributes)
		{
			sstream << fmt::format("	rttr::metadata(\"{}\", {}),", attribute.name, attribute.value) << std::endl;
		}
		sstream.seekp(-2, std::ios_base::end);
		sstream << std::endl;
		sstream << ")" << std::endl;
	}
}

std::string GenerateTypeInfo(const std::vector<std::string> &headers, const std::vector<Meta::TypeMeta> &meta_types)
{
	std::stringstream result;

	result << "#pragma once" << std::endl
	       << "#include <rttr/registration.h>" << std::endl;
	for (auto &header : headers)
	{
		result << fmt::format("#include \"{}\"", header) << std::endl;
	}
	result << "// This code is generated by meta generator" << std::endl
	       << "RTTR_REGISTRATION" << std::endl
	       << "{" << std::endl;

	for (auto &meta : meta_types)
	{
		std::string namespace_ = "";
		for (auto &ns : meta._namespaces)
		{
			namespace_ += ns + "::";
		}

		std::string name = namespace_ + meta.name;

		switch (meta.mode)
		{
			case Meta::TypeMeta::Mode::Enum: {
				result << fmt::format("rttr::registration::enumeration<{}>(\"{}\")", name, meta.name) << std::endl;
				GenerateAttribute(result, meta.attributes);
				result << "(" << std::endl;
				for (auto &field : meta.fields)
				{
					result << fmt::format("	rttr::value(\"{}\", {}::{}),", field.name, name, field.name) << std::endl;
				}
				result.seekp(-2, std::ios_base::end);
				result << std::endl;
				result << ");" << std::endl
				       << std::endl;
			}
			break;
			case Meta::TypeMeta::Mode::Class:
			case Meta::TypeMeta::Mode::Struct:
				result << fmt::format("registration::class_<{}>(\"{}\")", name, meta.name) << std::endl;
				GenerateAttribute(result, meta.attributes);
				for (auto &field : meta.fields)
				{
					if (field.access_specifier == Meta::AccessSpecifier::Public)
					{
						switch (field.mode)
						{
							case Meta::Field::Mode::Variable:
								result << fmt::format("	.property(\"{}\", &{}::{})", field.name, name, field.name) << std::endl;
								GenerateAttribute(result, field.attributes);
								break;
							case Meta::Field::Mode::Function:
								// Method
								result << fmt::format("	.method(\"{}\", &{}::{})", field.name, name, field.name) << std::endl;
								// Constructor
								// Overload
								GenerateAttribute(result, field.attributes);
								break;
							default:
								break;
						}
					}
				}
				result << ";" << std::endl;
				break;
			default:
				break;
		}
	}

	result << "}" << std::endl;

	return result.str();
}
}        // namespace Ilum