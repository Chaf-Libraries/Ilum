#pragma once
#include <rttr/registration.h>
#include "E:/Workspace/Ilum/Source/Ilum/RenderCore/Precompile.hpp"
#include "E:/Workspace/Ilum/Source/Ilum/RenderCore/RenderGraph/RenderGraph.hpp"
#include "E:/Workspace/Ilum/Source/Ilum/RenderCore/RenderGraph/RenderGraphBuilder.hpp"
#include "E:/Workspace/Ilum/Source/Ilum/RenderCore/ShaderCompiler/ShaderCompiler.hpp"
#include "E:/Workspace/Ilum/Source/Ilum/RenderCore/ShaderCompiler/SpirvReflection.hpp"
// This code is generated by meta generator
namespace NAMESPACE_4773644180934523656
{
RTTR_REGISTRATION
{
using namespace Ilum;

rttr::registration::class_<Ilum::RenderPassName>("Ilum::RenderPassName")
	.property("name", &Ilum::RenderPassName::name)
	.property("next", &Ilum::RenderPassName::next)
	.constructor<const char*, const RenderPassName*&>();

rttr::registration::class_<Ilum::RGHandle>("Ilum::RGHandle")
	.property("handle", &Ilum::RGHandle::handle)
	.constructor<>()
	.constructor<size_t>()
	.method("IsValid", &Ilum::RGHandle::IsValid)
	.method("GetHandle", &Ilum::RGHandle::GetHandle);

rttr::registration::enumeration<Ilum::RenderResourceDesc::Type>("Ilum::RenderResourceDesc::Type")
(
	rttr::value("Buffer", Ilum::RenderResourceDesc::Type::Buffer),
	rttr::value("Texture", Ilum::RenderResourceDesc::Type::Texture)
);

rttr::registration::enumeration<Ilum::RenderResourceDesc::Attribute>("Ilum::RenderResourceDesc::Attribute")
(
	rttr::value("Read", Ilum::RenderResourceDesc::Attribute::Read),
	rttr::value("Write", Ilum::RenderResourceDesc::Attribute::Write)
);

rttr::registration::class_<Ilum::RenderResourceDesc>("Ilum::RenderResourceDesc")
	.property("type", &Ilum::RenderResourceDesc::type)
	.property("attribute", &Ilum::RenderResourceDesc::attribute)
	.property("state", &Ilum::RenderResourceDesc::state)
	.property("handle", &Ilum::RenderResourceDesc::handle);

rttr::registration::class_<Ilum::RenderPassDesc>("Ilum::RenderPassDesc")
	.property("name", &Ilum::RenderPassDesc::name)
	.property("config", &Ilum::RenderPassDesc::config)
	.property("resources", &Ilum::RenderPassDesc::resources)
	.property("prev_pass", &Ilum::RenderPassDesc::prev_pass)
	.method("Write", &Ilum::RenderPassDesc::Write)
	.method("Read", &Ilum::RenderPassDesc::Read);

rttr::registration::class_<Ilum::RenderGraphDesc>("Ilum::RenderGraphDesc")
	.property("passes", &Ilum::RenderGraphDesc::passes)
	.property("textures", &Ilum::RenderGraphDesc::textures)
	.property("buffers", &Ilum::RenderGraphDesc::buffers);

rttr::registration::class_<Ilum::RenderGraph>("Ilum::RenderGraph")
	.constructor<RHIContext*>()
	.method("GetTexture", &Ilum::RenderGraph::GetTexture)
	.method("GetBuffer", &Ilum::RenderGraph::GetBuffer)
	.method("Execute", &Ilum::RenderGraph::Execute);

rttr::registration::enumeration<Ilum::ShaderSource>("Ilum::ShaderSource")
(
	rttr::value("HLSL", Ilum::ShaderSource::HLSL),
	rttr::value("GLSL", Ilum::ShaderSource::GLSL)
);

rttr::registration::enumeration<Ilum::ShaderTarget>("Ilum::ShaderTarget")
(
	rttr::value("SPIRV", Ilum::ShaderTarget::SPIRV),
	rttr::value("DXIL", Ilum::ShaderTarget::DXIL),
	rttr::value("PTX", Ilum::ShaderTarget::PTX)
);

rttr::registration::class_<Ilum::ShaderDesc>("Ilum::ShaderDesc")
	.property("code", &Ilum::ShaderDesc::code)
	.property("source", &Ilum::ShaderDesc::source)
	.property("target", &Ilum::ShaderDesc::target)
	.property("stage", &Ilum::ShaderDesc::stage)
	.property("entry_point", &Ilum::ShaderDesc::entry_point)
	.property("macros", &Ilum::ShaderDesc::macros);

rttr::registration::class_<Ilum::ShaderCompiler>("Ilum::ShaderCompiler")
	.constructor<>()
	.method("Compile", &Ilum::ShaderCompiler::Compile);

rttr::registration::class_<Ilum::SpirvReflection>("Ilum::SpirvReflection")
	.method("Reflect", &Ilum::SpirvReflection::Reflect);

}
}

//Generate for Serialization
template <class Archive>
void serialize(Archive& archive, Ilum::RenderPassName& v)
{
	archive(v.name, v.next);
}

template <class Archive>
void serialize(Archive& archive, Ilum::RGHandle& v)
{
	archive(v.handle);
}

template <class Archive>
void serialize(Archive& archive, Ilum::RenderResourceDesc& v)
{
	archive(v.type, v.attribute, v.state, v.handle);
}

template <class Archive>
void serialize(Archive& archive, Ilum::RenderPassDesc& v)
{
	archive(v.name, v.config, v.resources, v.prev_pass);
}

template <class Archive>
void serialize(Archive& archive, Ilum::RenderGraphDesc& v)
{
	archive(v.passes, v.textures, v.buffers);
}

template <class Archive>
void serialize(Archive& archive, Ilum::RenderGraph& v)
{
	archive();
}

template <class Archive>
void serialize(Archive& archive, Ilum::ShaderDesc& v)
{
	archive(v.code, v.source, v.target, v.stage, v.entry_point, v.macros);
}

template <class Archive>
void serialize(Archive& archive, Ilum::ShaderCompiler& v)
{
	archive();
}

template <class Archive>
void serialize(Archive& archive, Ilum::SpirvReflection& v)
{
	archive();
}

