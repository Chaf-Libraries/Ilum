#pragma once
#include <rttr/registration.h>
#include "E:/Workspace/Ilum/Source/Ilum/RHI/RHIPipelineState.hpp"
// This code is generated by meta generator
namespace NAMESPACE_17444793135543355979
{
RTTR_REGISTRATION
{
using namespace Ilum;

rttr::registration::class_<Ilum::DepthStencilState>("Ilum::DepthStencilState")
	.property("depth_test_enable", &Ilum::DepthStencilState::depth_test_enable)
	.property("depth_write_enable", &Ilum::DepthStencilState::depth_write_enable)
	.property("compare", &Ilum::DepthStencilState::compare);

rttr::registration::class_<Ilum::BlendState::AttachmentState>("Ilum::BlendState::AttachmentState")
	.property("blend_enable", &Ilum::BlendState::AttachmentState::blend_enable)
	.property("src_color_blend", &Ilum::BlendState::AttachmentState::src_color_blend)
	.property("dst_color_blend", &Ilum::BlendState::AttachmentState::dst_color_blend)
	.property("color_blend_op", &Ilum::BlendState::AttachmentState::color_blend_op)
	.property("src_alpha_blend", &Ilum::BlendState::AttachmentState::src_alpha_blend)
	.property("dst_alpha_blend", &Ilum::BlendState::AttachmentState::dst_alpha_blend)
	.property("alpha_blend_op", &Ilum::BlendState::AttachmentState::alpha_blend_op)
	.property("color_write_mask", &Ilum::BlendState::AttachmentState::color_write_mask);

rttr::registration::class_<Ilum::BlendState>("Ilum::BlendState")
	.property("enable", &Ilum::BlendState::enable)
	.property("logic_op", &Ilum::BlendState::logic_op)
	.property("blend_constants", &Ilum::BlendState::blend_constants)
	.property("attachment_states", &Ilum::BlendState::attachment_states);

rttr::registration::class_<Ilum::RasterizationState>("Ilum::RasterizationState")
	.property("cull_mode", &Ilum::RasterizationState::cull_mode)
	.property("front_face", &Ilum::RasterizationState::front_face)
	.property("polygon_mode", &Ilum::RasterizationState::polygon_mode)
	.property("depth_bias", &Ilum::RasterizationState::depth_bias)
	.property("depth_bias_clamp", &Ilum::RasterizationState::depth_bias_clamp)
	.property("depth_bias_slope", &Ilum::RasterizationState::depth_bias_slope);

rttr::registration::class_<Ilum::VertexInputState::InputBinding>("Ilum::VertexInputState::InputBinding")
	.property("binding", &Ilum::VertexInputState::InputBinding::binding)
	.property("stride", &Ilum::VertexInputState::InputBinding::stride)
	.property("rate", &Ilum::VertexInputState::InputBinding::rate);

rttr::registration::class_<Ilum::VertexInputState::InputAttribute>("Ilum::VertexInputState::InputAttribute")
	.property("semantics", &Ilum::VertexInputState::InputAttribute::semantics)
	.property("location", &Ilum::VertexInputState::InputAttribute::location)
	.property("binding", &Ilum::VertexInputState::InputAttribute::binding)
	.property("format", &Ilum::VertexInputState::InputAttribute::format)
	.property("offset", &Ilum::VertexInputState::InputAttribute::offset);

rttr::registration::class_<Ilum::VertexInputState>("Ilum::VertexInputState")
	.property("input_attributes", &Ilum::VertexInputState::input_attributes)
	.property("input_bindings", &Ilum::VertexInputState::input_bindings);

rttr::registration::class_<Ilum::InputAssemblyState>("Ilum::InputAssemblyState")
	.property("topology", &Ilum::InputAssemblyState::topology);

}
}

//Generate for Serialization
template <class Archive>
void serialize(Archive& archive, Ilum::DepthStencilState& v)
{
	archive(v.depth_test_enable, v.depth_write_enable, v.compare);
}

template <class Archive>
void serialize(Archive& archive, Ilum::BlendState::AttachmentState& v)
{
	archive(v.blend_enable, v.src_color_blend, v.dst_color_blend, v.color_blend_op, v.src_alpha_blend, v.dst_alpha_blend, v.alpha_blend_op, v.color_write_mask);
}

template <class Archive>
void serialize(Archive& archive, Ilum::BlendState& v)
{
	archive(v.enable, v.logic_op, v.blend_constants, v.attachment_states);
}

template <class Archive>
void serialize(Archive& archive, Ilum::RasterizationState& v)
{
	archive(v.cull_mode, v.front_face, v.polygon_mode, v.depth_bias, v.depth_bias_clamp, v.depth_bias_slope);
}

template <class Archive>
void serialize(Archive& archive, Ilum::MultisampleState& v)
{
	archive(v.enable, v.samples, v.sample_mask);
}

template <class Archive>
void serialize(Archive& archive, Ilum::VertexInputState::InputBinding& v)
{
	archive(v.binding, v.stride, v.rate);
}

template <class Archive>
void serialize(Archive& archive, Ilum::VertexInputState::InputAttribute& v)
{
	archive(v.semantics, v.location, v.binding, v.format, v.offset);
}

template <class Archive>
void serialize(Archive& archive, Ilum::VertexInputState& v)
{
	archive(v.input_attributes, v.input_bindings);
}

template <class Archive>
void serialize(Archive& archive, Ilum::InputAssemblyState& v)
{
	archive(v.topology);
}

template <class Archive>
void serialize(Archive& archive, Ilum::RHIPipelineState& v)
{
	archive();
}

