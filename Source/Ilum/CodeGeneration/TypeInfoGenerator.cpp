#include "TypeInfoGenerator.hpp"

#include <spdlog/fmt/fmt.h>

#include <sstream>

namespace Ilum
{
std::string GenerateTypeInfo(const std::vector<std::string> &headers, const std::vector<Meta::MetaType> &meta_types)
{
	std::stringstream result;

	result << "#pragma once" << std::endl
	       << "#include <rttr/registration.h>" << std::endl;
	for (auto &header : headers)
	{
		result << fmt::format("#include \"{}\"", header) << std::endl;
	}
	result << "// This code is generated by meta generator" << std::endl
	       << "RTTR_REGISTRATION" << std::endl
	       << "{" << std::endl;

	for (auto &meta : meta_types)
	{
		switch (meta.mode)
		{
			case Meta::MetaType::Mode::Enum:

			{
				std::string namespace_ = "";
				for (auto &ns : meta._namespaces)
				{
					namespace_ += ns + "::";
				}

				std::string name = namespace_ + meta.name;

				result << fmt::format("rttr::registration::enumeration<{}>(\"{}\")", name, meta.name) << std::endl;

				if (!meta.attributes.empty())
				{
					result << "(" << std::endl;
					for (auto &attribute : meta.attributes)
					{
						result << fmt::format("	rttr::metadata(\"{}\", {}),", attribute.name, attribute.value) << std::endl;
					}
					result.seekp(-2, std::ios_base::end);
					result << std::endl;
					result << ")" << std::endl;
				}

				result << "(" << std::endl;
				for (auto &field : meta.fields)
				{
					result << fmt::format("	rttr::value(\"{}\", {}::{}),", field.name, name, field.name) << std::endl;
				}
				result.seekp(-2, std::ios_base::end);
				result << std::endl;
				result << ");" << std::endl
				       << std::endl;
			}

			break;
			default:
				break;
		}
	}

	result << "}" << std::endl;

	return result.str();
}
}        // namespace Ilum