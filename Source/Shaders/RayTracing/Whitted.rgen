#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable

#include "../RayTracing.glsl"
#include "../Material.glsl"

layout(push_constant) uniform PushBlock
{
	uint anti_alias;
	uint directional_light_count;
	uint spot_light_count;
	uint point_light_count;
	int max_bounce;
	float parameter;
}
push_data;

layout(location = 0) rayPayloadEXT RayPayload ray_payload;
layout(location = 1) rayPayloadEXT ShadowPayload shadow_payload;

bool Unoccluded(VisibilityTester vis)
{
	shadow_payload.visibility = false;
	Ray shadow_ray;
	shadow_ray.direction = normalize(vis.to.position - vis.from.position);
	shadow_ray.origin    = OffsetRay(vis.from.position, dot(shadow_ray.direction, vis.from.normal) > 0 ? vis.from.normal : -vis.from.normal);
	shadow_ray.tmin      = 0.0;
	shadow_ray.tmax      = length(vis.to.position - vis.from.position);

	// Trace shadow ray
	traceRayEXT(topLevelAS,                                                                                                            // acceleration structure
	            gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT | gl_RayFlagsCullBackFacingTrianglesEXT,        // rayFlags
	            0xFF,                                                                                                                  // cullMask
	            0,                                                                                                                     // sbtRecordOffset
	            0,                                                                                                                     // sbtRecordStride
	            1,                                                                                                                     // missIndex
	            shadow_ray.origin,                                                                                                     // ray origin
	            shadow_ray.tmin,                                                                                                       // ray min range
	            shadow_ray.direction,                                                                                                  // ray direction
	            shadow_ray.tmax,                                                                                                       // ray max range
	            1                                                                                                                      // payload (location = 1)
	);

	return shadow_payload.visibility;
}

bool Unoccluded(Interaction from, vec3 dir, float dist)
{
	shadow_payload.visibility = false;
	Ray shadow_ray;
	shadow_ray.direction = normalize(dir);
	shadow_ray.origin    = OffsetRay(from.position, dot(shadow_ray.direction, from.normal) > 0 ? from.normal : -from.normal);
	shadow_ray.tmin      = 0.0;
	shadow_ray.tmax      = dist;

	// Trace shadow ray
	traceRayEXT(topLevelAS,                                                                                                            // acceleration structure
	            gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT | gl_RayFlagsCullBackFacingTrianglesEXT,        // rayFlags
	            0xFF,                                                                                                                  // cullMask
	            0,                                                                                                                     // sbtRecordOffset
	            0,                                                                                                                     // sbtRecordStride
	            1,                                                                                                                     // missIndex
	            shadow_ray.origin,                                                                                                     // ray origin
	            shadow_ray.tmin,                                                                                                       // ray min range
	            shadow_ray.direction,                                                                                                  // ray direction
	            shadow_ray.tmax,                                                                                                       // ray max range
	            1                                                                                                                      // payload (location = 1)
	);

	return shadow_payload.visibility;
}

bool IntersectScene(Ray ray)
{
	// Spawn a ray
	ray_payload.hitT = Infinity;
	traceRayEXT(topLevelAS,   // acceleration structure
			gl_RayFlagsCullBackFacingTrianglesEXT,     // rayFlags
			0xFF,         // cullMask
			0,            // sbtRecordOffset
			0,            // sbtRecordStride
			0,            // missIndex
			ray.origin,     // ray origin
			ray.tmin,          // ray min range
			ray.direction,  // ray direction
			ray.tmax,     // ray max range
			0             // payload (location = 0)
	);

	return ray_payload.hitT != Infinity;
}

void main() 
{
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	ray_payload.seed = init_random(gl_LaunchSizeEXT.xy, gl_LaunchIDEXT.xy, camera_data.frame_num);

	vec2 jitter = vec2(0.0);

	if(push_data.anti_alias == 1)
	{
		jitter = rand2(ray_payload.seed) - vec2(0.5);
	}

	const vec2 screen_coords = (pixelCenter + jitter) / vec2(gl_LaunchSizeEXT.xy) * 2.0 - 1.0;

	Ray ray = CameraCastRay(camera_data, screen_coords);

	vec3 radiance = vec3(0.0);
	vec3 throughout = vec3(1.0);
	vec3 absorption = vec3(0.0);

	for(int depth = 0; depth < push_data.max_bounce; depth++)
	{
		// Hit environment
		if(!IntersectScene(ray))
		{
			radiance += texture(Skybox, ray.direction).rgb;
			break;
		}

		Interaction interaction = GetInteraction(ray_payload);
		interaction.normal = dot(interaction.normal, ray.direction) <= 0.0 ? interaction.normal : -interaction.normal;
		CreateCoordinateSystem(interaction.normal, interaction.tangent, interaction.bitangent);

		vec3 n = interaction.normal;
		vec3 wo = -ray.direction;

		//LambertianReflection mat;
		MatteMaterial mat;
		vec3 base_color = vec3(0.0);
		if(interaction.material.textures[TEXTURE_BASE_COLOR] < 1024)
		{
			base_color = texture(texture_array[nonuniformEXT(interaction.material.textures[TEXTURE_BASE_COLOR])], interaction.texcoord).rgb;
		}
		else
		{
			base_color = interaction.material.base_color.rgb;
		}
		Init(mat, base_color, push_data.parameter);

		// Add contribution of each point light source
		for(uint i = 0; i < push_data.point_light_count; i++)
		{
			vec3 wi;
			float pdf;
			VisibilityTester vis;
			vec3 Li = Sample_Li(point_lights[i], interaction, rand2(ray_payload.seed), wi, pdf, vis);
			if(Li == vec3(0.0) || pdf == 0)
			{
				continue;
			}

			if(Li != vec3(0.0) && Unoccluded(vis))
			{
				vec3 f = Distribution(mat, wo, wi);
				radiance += throughout * f * Li * abs(dot(wi, interaction.normal)) / pdf;
			}
		}

		// Add contribution of each point light source
		for(uint i = 0; i < push_data.spot_light_count; i++)
		{
			vec3 wi;
			float pdf;
			VisibilityTester vis;
			vec3 Li = Sample_Li(spot_lights[i], interaction, rand2(ray_payload.seed), wi, pdf, vis);
			if(Li == vec3(0.0) || pdf == 0)
			{
				continue;
			}

			if(Li != vec3(0.0) && Unoccluded(vis))
			{
				vec3 f = Distribution(mat, wo, wi);
				radiance += throughout * f * Li * abs(dot(wi, interaction.normal)) / pdf;
			}
		}

		// Add contribution of each point light source
		for(uint i = 0; i < push_data.directional_light_count; i++)
		{
			vec3 wi;
			float pdf;
			VisibilityTester vis;
			vec3 Li = Sample_Li(directional_lights[i], interaction, rand2(ray_payload.seed), wi, pdf, vis);
			if(Li == vec3(0.0) || pdf == 0)
			{
				continue;
			}

			if(Li != vec3(0.0) && Unoccluded(interaction, -directional_lights[i].direction, Infinity))
			{
				vec3 f = Distribution(mat, wo, wi);
				radiance += throughout * f * Li * abs(dot(wi, interaction.normal)) / pdf;
			}
		}

		vec3 wi;
		float pdf;
		
		wo = WorldToLocal(wo, interaction.normal, interaction.tangent, interaction.bitangent);
		vec3 f = SampleDistribution(mat, wo, ray_payload.seed, wi, pdf);
		wi = LocalToWorld(wo, interaction.normal, interaction.tangent, interaction.bitangent);

		if(pdf > 0.0 && f != vec3(0.0) && abs(dot(wi, interaction.normal)) != 0.0)
		{
			throughout *= f * abs(dot(wi, interaction.normal)) / pdf;
			ray.direction = wi;
			ray.origin = OffsetRay(interaction.position, dot(ray.direction, interaction.normal) > 0 ? interaction.normal : -interaction.normal);
		}
		else
		{
			break;
		}
	}
	
	ivec2 launch_id = ivec2(gl_LaunchIDEXT.x, gl_LaunchSizeEXT.y - gl_LaunchIDEXT.y);

	if(camera_data.frame_num == 0)
	{
		imageStore(Image, launch_id, vec4(radiance, 1.0));
	}
	else
	{
		vec3 prev_color = imageLoad(PrevImage, launch_id).rgb;
		vec3 accumulated_color = vec3(0.0);
		
		if((isnan(prev_color.x) && isnan(prev_color.y) && isnan(prev_color.z)))
		{
			accumulated_color = radiance;
		}
		else
		{
			accumulated_color =mix(prev_color, radiance, 1.0 / float(camera_data.frame_num + 1));
		}

		imageStore(Image, launch_id, vec4(accumulated_color, 1.0));
	}
}
