#version 460

#extension GL_KHR_vulkan_glsl : enable
#extension GL_GOOGLE_include_directive: enable

#include "../../GlobalBuffer.glsl"
#include "../../GlobalFunction.glsl"
#include "../../BxDF.glsl"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D GBuffer0;
layout(set = 0, binding = 1) uniform sampler2D GBuffer1;
layout(set = 0, binding = 2) uniform sampler2D GBuffer2;
layout(set = 0, binding = 3) uniform sampler2D GBuffer3;
layout(set = 0, binding = 4) uniform sampler2D GBuffer4;
layout(set = 0, binding = 5) uniform sampler2D GBuffer5;
layout(set = 0, binding = 6) uniform sampler2D DepthBuffer;
layout(set = 0, binding = 7) uniform sampler2D EmuLut;
layout(set = 0, binding = 8) uniform sampler2D EavgLut;
layout(set = 0, binding = 9) uniform sampler2DArray ShadowMaps;


layout(set = 0, binding = 10) buffer DirectionalLights{
    DirectionalLight directional_lights[ ];
};

layout(set = 0, binding = 11) buffer PointLights{
    PointLight point_lights[ ];
};

layout(set = 0, binding = 12) buffer SpotLights{
    SpotLight spot_lights[ ];
};

layout(set = 0, binding = 13) uniform CameraBuffer
{
	CameraData camera_data;
};

layout(set = 0, binding = 14, rgba16f) writeonly uniform image2D Lighting;

layout(push_constant) uniform PushBlock{
    uint directional_light_count;
    uint spot_light_count;
    uint point_light_count;
    uint enable_multi_bounce;
    uvec2 extent;
    uint pcf_enable;
    float pcf_sample_scale;
    int pcf_sample_num;
    int pcf_sample_method;
}push_data;

// Depth buffer to world position
vec3 world_position_from_depth(vec2 uv, float depth, mat4 view_projection_inverse)
{
    uv.y = 1.0 - uv.y;
    vec2 screen_pos = uv * 2.0 - 1.0;
    vec4 ndc_pos = vec4(screen_pos, depth, 1.0);
    vec4 world_pos = view_projection_inverse * ndc_pos;
    world_pos = world_pos / world_pos.w;
    return world_pos.xyz;
}

float sample_shadowmap(vec4 p, float layer, vec2 offset)
{
    float shadow = 1.0;
	vec4 shadow_coord = p / p.w;
	shadow_coord.st = shadow_coord.st * 0.5 + 0.5;
    shadow_coord.t = 1.0 - shadow_coord.t;
	
	if (shadow_coord.z > -1.0 && shadow_coord.z < 1.0) 
	{
		float dist = texture(ShadowMaps, vec3(shadow_coord.st + offset, layer)).r;
		if (shadow_coord.w > 0.0 && dist < shadow_coord.z) 
		{
			shadow = 0.0;
		}
	}
	return shadow;
}

float sample_shadowmap_pcf(vec4 p, float layer)
{
    ivec2 tex_dim = textureSize(ShadowMaps, 0).xy;
    float dx = push_data.pcf_sample_scale / float(tex_dim.x);
    float dy = push_data.pcf_sample_scale / float(tex_dim.y);

    float shadow_factor = 0.0;

    // Uniform sampling
    if(push_data.pcf_sample_method == 0)
    {
        vec2 offset = vec2(0.0);
        for(int i = 0; i < push_data.pcf_sample_num; i++)
        {
            offset = uniform_disk_samples(vec2(p.xy / p.w) + offset);
            offset = offset * push_data.pcf_sample_scale / vec2(tex_dim);
            shadow_factor += sample_shadowmap(p, layer, offset);
        }
    }
    // Poisson sampling
    else if(push_data.pcf_sample_method == 1)
    {
        for(int i = 0; i < push_data.pcf_sample_num; i++)
        {
            vec2 offset = poisson_disk_samples(vec2(p.xy / p.w), push_data.pcf_sample_num, 10, i);
            offset = offset * push_data.pcf_sample_scale / vec2(tex_dim);
            shadow_factor += sample_shadowmap(p, layer, offset);
        }
    }

    return shadow_factor / float(push_data.pcf_sample_num);
}

// Calculate BRDF contribution for specific parameter
vec3 brdf_contribution(vec3 L, vec3 V, vec3 N, vec3 radiance, MaterialData material)
{
    vec3 tangent = normalize(cross( vec3(0,1,0), N));
    vec3 bitangent = normalize(cross(N, tangent));

    vec3 BRDF = vec3(0.0);

    if(material.material_type == BxDF_Disney)
    {
        BRDF += DisneyBRDF(L, V, N, tangent, bitangent, material);
    }
    else if(material.material_type == BxDF_CookTorrance)
    {
        BRDF += CookTorranceBRDF(L, V, N, tangent, bitangent, material);

        if(push_data.enable_multi_bounce == 1)
        {
            vec3 Eo = vec3(texture(EmuLut, vec2(dot(N, L), material.roughness)).r);
            vec3 Ei = vec3(texture(EmuLut, vec2(dot(N, V), material.roughness)).r);
            float Eavg = texture(EavgLut, vec2(0, material.roughness)).r;
            vec3 Fms = MultiScatterBRDF(pow(material.base_color.rgb, vec3(2.2)), Eo, Ei, Eavg);
            BRDF += Fms;
        }
    }

    return BRDF * radiance * clamp(dot(N, L), 0.0, 1.0);
}

// BRDF contribution for directional light
vec3 direction_light_contribution(DirectionalLight light, vec3 V, vec3 N, MaterialData material)
{
       vec3 L = normalize(light.direction);
       vec3 radiance = light.color.rgb * light.intensity;
       return brdf_contribution(L, V, N, radiance, material);
}

// BRDF contribution for spot light
vec3 spot_light_contribution(SpotLight light, vec3 V, vec3 N, vec3 frag_pos, MaterialData material)
{
       vec3 L = normalize(light.position - frag_pos);
       float NoL = max(0.0, dot(N,L));
       float theta = dot(L, normalize(-light.direction));
       float epsilon   = light.cut_off - light.outer_cut_off;
       float intensity = light.intensity * clamp((theta - light.outer_cut_off) / epsilon, 0.0, 1.0);
       vec3 radiance = light.color * intensity;
       return brdf_contribution(L, V, N, radiance, material);
}

// BRDF contribution for point light
vec3 point_light_contribution(PointLight light, vec3 V, vec3 N, vec3 frag_pos, MaterialData material)
{
       vec3 L = normalize(light.position - frag_pos);
       float d = length(light.position - frag_pos);
       float NoL = max(0.0, dot(N,L));
       float Fatt = 1.0/(light.constant + light.linear * d + light.quadratic * d * d);
       vec3 radiance = light.color.rgb * light.intensity * Fatt;
       return brdf_contribution(L, V, N, radiance, material);
}

// Shadow for spot light
vec3 spot_light_shadow(SpotLight light, vec3 frag_color, vec3 frag_pos, float layer)
{
    vec4 shadow_clip = light.view_projection * vec4(frag_pos, 1.0);
    float shadow_factor = 0.0;
    if(push_data.pcf_enable == 1)
    {
        shadow_factor = sample_shadowmap_pcf(shadow_clip, layer);
    }
    else
    {
        shadow_factor = sample_shadowmap(shadow_clip, layer, vec2(0.0));
    }
    frag_color *=shadow_factor;
    return frag_color;
}

void main()
{
    if(gl_GlobalInvocationID.x > push_data.extent.x || gl_GlobalInvocationID.y > push_data.extent.y)
    {
        return;
    }

    vec2 uv = (vec2(gl_GlobalInvocationID.xy)+vec2(0.5)) / vec2(push_data.extent);

    vec4 gbuffer0 = texture(GBuffer0, uv);
    vec4 gbuffer1 = texture(GBuffer1, uv);
    vec4 gbuffer2 = texture(GBuffer2, uv);
    vec4 gbuffer3 = texture(GBuffer3, uv);
    vec4 gbuffer4 = texture(GBuffer4, uv);
    vec4 gbuffer5 = texture(GBuffer5, uv);
    float depth = texture(DepthBuffer, uv).r;

    // GBuffer 0: RGB - Albedo, A - Anisotropic
	// GBuffer 1: RGB - Normal, A - Linear Depth
	// GBuffer 2: R - Metallic, G - Roughness, B - Subsurface, A - EntityID
	// GBuffer 3: R - Sheen, G - Sheen Tint, B - Clearcoat, A - Clearcoat Gloss
	// GBuffer 4: RG - Velocity, B - Specular, A - Specular Tint
	// GBuffer 5: RGB - Emissive, A - Material Type

    MaterialData material;

    material.base_color = vec4(gbuffer0.rgb, 1.0);
    material.emissive_color = gbuffer5.rgb;
	material.subsurface = gbuffer2.b;
	material.metallic = gbuffer2.r;
	material.specular = gbuffer4.b;
	material.specular_tint = gbuffer4.a;
	material.roughness = clamp(gbuffer2.g, 0.01, 0.99);
	material.anisotropic = gbuffer0.a;
	material.sheen = gbuffer3.r;
	material.sheen_tint = gbuffer3.g;
	material.clearcoat = gbuffer3.b;
	material.clearcoat_gloss = gbuffer3.a;
    material.material_type = uint(gbuffer5.a);

    vec3 normal = gbuffer1.rgb;

    vec3 frag_pos = world_position_from_depth(uv, depth, camera_data.view_inverse * camera_data.projection_inverse);

   vec3 Lo = vec3(0.0);
   vec4 out_color = vec4(0.0, 0.0, 0.0,1.0);
   vec3 V = normalize(camera_data.position - frag_pos);
   vec3 N = normalize(normal);
      
   // Directional light
   for(uint i = 0; i < push_data.directional_light_count; i++)
   {
       Lo += direction_light_contribution(directional_lights[i], V, N, material);
   }
   
   // Spot light
   for(uint i = 0; i< push_data.spot_light_count; i++)
   {
        Lo += spot_light_shadow(spot_lights[i], spot_light_contribution(spot_lights[i], V, N, frag_pos, material), frag_pos, float(i));
   }
   
   // Point Light
   for(uint i = 0; i< push_data.point_light_count; i++)
   {
        Lo += point_light_contribution(point_lights[i], V, N, frag_pos, material);
   }
   
   vec3 color = Lo + material.emissive_color;
   
    imageStore(Lighting, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}
