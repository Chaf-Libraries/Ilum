#version 460

#extension GL_KHR_vulkan_glsl : enable
#extension GL_GOOGLE_include_directive: enable

#include "../../GlobalBuffer.glsl"
#include "../../GlobalFunction.glsl"
#include "../../BxDF.glsl"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D GBuffer0;
layout(set = 0, binding = 1) uniform sampler2D GBuffer1;
layout(set = 0, binding = 2) uniform sampler2D GBuffer2;
layout(set = 0, binding = 3) uniform sampler2D GBuffer3;
layout(set = 0, binding = 4) uniform sampler2D GBuffer4;
layout(set = 0, binding = 5) uniform sampler2D GBuffer5;
layout(set = 0, binding = 6) uniform sampler2D DepthBuffer;
layout(set = 0, binding = 7) uniform sampler2D EmuLut;
layout(set = 0, binding = 8) uniform sampler2D EavgLut;
layout(set = 0, binding = 9) uniform sampler2DArray ShadowMaps;
layout(set = 0, binding = 10) uniform sampler2DArray CascadeShadowMaps;
layout(set = 0, binding = 11) uniform samplerCubeArray OmniShadowMaps;

layout(set = 0, binding = 12) buffer DirectionalLights{
    DirectionalLight directional_lights[ ];
};

layout(set = 0, binding = 13) buffer PointLights{
    PointLight point_lights[ ];
};

layout(set = 0, binding = 14) buffer SpotLights{
    SpotLight spot_lights[ ];
};

layout(set = 0, binding = 15) uniform CameraBuffer
{
	CameraData camera_data;
};

layout(set = 0, binding = 16, rgba16f) writeonly uniform image2D Lighting;

layout(push_constant) uniform PushBlock{
    uint directional_light_count;
    uint spot_light_count;
    uint point_light_count;
    uint enable_multi_bounce;
    uvec2 extent;
}push_data;

float linearize_depth(float depth, float znear, float zfar)
{
    float z = depth * 2.0 - 1.0;
    return znear * zfar / (zfar + depth * (znear - zfar));
}

// Depth buffer to world position
vec3 world_position_from_depth(vec2 uv, float depth, mat4 view_projection_inverse)
{
    uv.y = 1.0 - uv.y;
    vec2 screen_pos = uv * 2.0 - 1.0;
    vec4 ndc_pos = vec4(screen_pos, depth, 1.0);
    vec4 world_pos = view_projection_inverse * ndc_pos;
    world_pos = world_pos / world_pos.w;
    return world_pos.xyz;
}

float sample_shadowmap(sampler2DArray shadowmap, vec4 shadow_coord, float layer, vec2 offset)
{
    float shadow = 1.0;
	
	if (shadow_coord.z > -1.0 && shadow_coord.z < 1.0) 
	{
		float dist = texture(shadowmap, vec3(shadow_coord.st + offset, layer)).r;
		if (shadow_coord.w > 0.0 && dist < shadow_coord.z)
		{
			shadow = 0.0;
		}
	}
	return shadow;
}

float sample_shadowmap_cube(samplerCubeArray shadowmap, vec3 L, float layer, vec3 offset)
{
    float shadow = 1.0;
    float light_depth = length(L);
    L.z = -L.z;
    // Reconstruct depth
	float dist = texture(shadowmap, vec4(L + offset, layer)).r;
    dist *= 100.0;

	if (light_depth > dist)
	{
		shadow = 0.0;
	}

	return shadow;
}

float sample_shadowmap_pcf(sampler2DArray shadowmap, vec4 shadow_coord, float layer, int filter_sample, float filter_scale, int sample_method)
{
    ivec2 tex_dim = textureSize(shadowmap, 0).xy;

    float shadow_factor = 0.0;

    vec2 offset = vec2(0.0);
    for(int i = 0; i < filter_sample; i++)
    {
        if(sample_method == 0)
        {
            // Uniform sampling
            offset = uniform_disk_samples_2d(shadow_coord.st + offset);
        }
        else if(sample_method == 1)
        {
            // Poisson sampling
            offset = poisson_disk_samples_2d(shadow_coord.st + offset, filter_sample, 10, i);
        }
        offset = offset * filter_scale / vec2(tex_dim);
        shadow_factor += sample_shadowmap(shadowmap, shadow_coord, layer, offset);
    }

    return shadow_factor / float(filter_sample);
}

float sample_shadowmap_cube_pcf(samplerCubeArray shadowmap, vec3 L, float layer, float filter_scale, int filter_sample, int sample_method)
{
    ivec2 tex_dim = textureSize(shadowmap, 0).xy;

    float shadow_factor = 0.0;
    float light_depth = length(L);
    
    float disk_radius = filter_scale / 100.0;

    vec3 offset = vec3(0.0);
    int count = 0;
    if(sample_method == 0)
    {
        for(int i = 0; i < filter_sample; i++)
        {
            // Uniform sampling
            offset = uniform_disk_samples_3d(L + offset) * disk_radius;
            shadow_factor += sample_shadowmap_cube(shadowmap, L, layer, offset);
        }
        count = filter_sample;
    }
    else if(sample_method == 1)
    {
        int x = int(sqrt(filter_sample));
        int y = filter_sample / x;
        count = x * y;
        for(int i = 0; i < x; i++)
        {
            for(int j = 0; j < y; j++)
            {
                // Poisson sampling
                offset = poisson_disk_samples_3d(L + offset, count, 10, vec2(i, j)) * disk_radius;
                shadow_factor += sample_shadowmap_cube(shadowmap, L, layer, offset);
            }
        }
    }

    return shadow_factor / float(count);
}

// PCSS find block
float find_block(sampler2DArray shadowmap, vec4 shadow_coord, float layer, float filter_scale, int filter_sample, int sample_method)
{
    ivec2 tex_dim = textureSize(ShadowMaps, 0).xy;

    // Find blocker
    float z_blocker = 0.0;
    float num_blockers = 0.0;
    vec2 offset = vec2(0.0);
    for(int i = 0; i < filter_sample; i++)
    {
        if(sample_method == 0)
        {
            // Uniform sampling
            offset = uniform_disk_samples_2d(shadow_coord.st + offset);
        }
        else if(sample_method == 1)
        {
            // Poisson sampling
            offset = poisson_disk_samples_2d(shadow_coord.st + offset, filter_sample, 10, i);
        }
        offset = offset * filter_scale / vec2(tex_dim);
        float dist = texture(shadowmap, vec3(shadow_coord.st + offset, layer)).r;
        if(dist < shadow_coord.z)
        {
            num_blockers += 1.0;
            z_blocker += dist;
        }
    }

    if(num_blockers == 0.0)
    {
        return 0.0;
    }

    return num_blockers == 0.0 ? 0.0 : z_blocker / num_blockers;
}

float find_block_cube(samplerCubeArray shadowmap, vec3 L, float layer, float filter_scale, int filter_sample, int sample_method)
{
    ivec2 tex_dim = textureSize(ShadowMaps, 0).xy;
    float light_depth = length(L);

    // Find blocker
    float z_blocker = 0.0;
    float num_blockers = 0.0;
    float disk_radius = filter_scale / 100.0;
    vec3 offset = vec3(0.0);

    if(sample_method == 0)
    {
        for(int i = 0; i < filter_sample; i++)
        {
            // Uniform sampling
            offset = uniform_disk_samples_3d(L + offset) * disk_radius;
            float dist = texture(shadowmap, vec4(L + offset, layer)).r;
            if (light_depth > dist)
            {
                num_blockers += 1.0;
                z_blocker += dist;
            }
        }
    }
    else if(sample_method == 1)
    {
        int x = int(sqrt(filter_sample));
        int y = filter_sample / x;
        for(int i = 0; i < x; i++)
        {
            for(int j = 0; j < y; j++)
            {
                // Poisson sampling
                offset = poisson_disk_samples_3d(L + offset, x * y, 10, vec2(i, j)) * disk_radius;
                float dist = texture(shadowmap, vec4(L + offset, layer)).r;
                if (light_depth > dist)
                {
                    num_blockers += 1.0;
                    z_blocker += dist;
                }
            }
        }
    }

    if(num_blockers == 0.0)
    {
        return 0.0;
    }

    return num_blockers == 0.0 ? 0.0 : z_blocker / num_blockers;
}

float sample_shadowmap_pcss(sampler2DArray shadowmap, vec4 shadow_coord, float layer, float filter_scale, int filter_sample, int sample_method, float light_size)
{
    ivec2 tex_dim = textureSize(shadowmap, 0).xy;
    float z_receiver = linearize_depth(shadow_coord.z, 0.01, 1000.0);

    // Penumbra size
    float z_blocker = linearize_depth(find_block(shadowmap, shadow_coord, layer, filter_scale, filter_sample, sample_method), 0.01, 1000.0);
    float w_light = 0.1;
    float w_penumbra = (z_receiver - z_blocker) * light_size / z_blocker;

    // Filtering
    float shadow_factor = 0.0;
    vec2 offset = vec2(0.0);
    for(int i = 0; i < filter_sample; i++)
    {
        if(sample_method == 0)
        {
            // Uniform sampling
            offset = uniform_disk_samples_2d(shadow_coord.st + offset);
        }
        else if(sample_method == 1)
        {
            // Poisson sampling
            offset = poisson_disk_samples_2d(shadow_coord.st + offset, filter_sample, 10, i);
        }
        offset = offset * w_penumbra / vec2(tex_dim);
        shadow_factor += sample_shadowmap(shadowmap, shadow_coord, layer, offset);
    }

    return shadow_factor / float(filter_sample);
}

float sample_shadowmap_cube_pcss(samplerCubeArray shadowmap, vec3 L, float layer, float filter_scale, int filter_sample, int sample_method, float light_size)
{
    ivec2 tex_dim = textureSize(shadowmap, 0).xy;
    float light_depth = length(L);
    float z_receiver = linearize_depth(light_depth, 0.01, 1000.0);

    // Penumbra size
    float z_blocker = linearize_depth(find_block_cube(shadowmap, L, layer, filter_scale, filter_sample, sample_method), 0.01, 1000.0);
    float w_light = 0.1;
    float w_penumbra = (z_receiver - z_blocker) * light_size / z_blocker;

    // Filtering
    float shadow_factor = 0.0;
    vec3 offset = vec3(0.0);
    float disk_radius = filter_scale / 100.0;
    int count = 0;

    if(sample_method == 0)
    {
        for(int i = 0; i < filter_sample; i++)
        {
            // Uniform sampling
            offset = uniform_disk_samples_3d(L + offset) * w_penumbra / float(tex_dim.x);
            shadow_factor += sample_shadowmap_cube(shadowmap, L, layer, offset);
        }
        count = filter_sample;
    }
    else if(sample_method == 1)
    {
        int x = int(sqrt(filter_sample));
        int y = filter_sample / x;
        count = x * y;
        for(int i = 0; i < x; i++)
        {
            for(int j = 0; j < y; j++)
            {
                // Poisson sampling
                offset = poisson_disk_samples_3d(L + offset, count, 10, vec2(i, j)) * w_penumbra / float(tex_dim.x);
                shadow_factor += sample_shadowmap_cube(shadowmap, L, layer, offset);
            }
        }
    }
    return shadow_factor / float(filter_sample);
}

// Calculate BRDF contribution for specific parameter
vec3 brdf_contribution(vec3 L, vec3 V, vec3 N, vec3 radiance, MaterialData material)
{
    vec3 tangent = normalize(cross( vec3(0,1,0), N));
    vec3 bitangent = normalize(cross(N, tangent));

    vec3 BRDF = vec3(0.0);

    if(material.material_type == BxDF_Disney)
    {
        BRDF += DisneyBRDF(L, V, N, tangent, bitangent, material);
    }
    else if(material.material_type == BxDF_CookTorrance)
    {
        BRDF += CookTorranceBRDF(L, V, N, tangent, bitangent, material);

        if(push_data.enable_multi_bounce == 1)
        {
            vec3 Eo = vec3(texture(EmuLut, vec2(dot(N, L), material.roughness)).r);
            vec3 Ei = vec3(texture(EmuLut, vec2(dot(N, V), material.roughness)).r);
            float Eavg = texture(EavgLut, vec2(0, material.roughness)).r;
            vec3 Fms = MultiScatterBRDF(pow(material.base_color.rgb, vec3(2.2)), Eo, Ei, Eavg);
            BRDF += Fms;
        }
    }

    return BRDF * radiance * clamp(dot(N, L), 0.0, 1.0);
}

// BRDF contribution for directional light
vec3 direction_light_contribution(DirectionalLight light, vec3 V, vec3 N, vec3 frag_pos, MaterialData material)
{
       vec3 L = normalize(-light.direction);
       vec3 radiance = light.color.rgb * light.intensity;
       return brdf_contribution(L, V, N, radiance, material);
}

// BRDF contribution for spot light
vec3 spot_light_contribution(SpotLight light, vec3 V, vec3 N, vec3 frag_pos, MaterialData material)
{
       vec3 L = normalize(light.position - frag_pos);
       float NoL = max(0.0, dot(N,L));
       float theta = dot(L, normalize(-light.direction));
       float epsilon   = light.cut_off - light.outer_cut_off;
       float intensity = light.intensity * clamp((theta - light.outer_cut_off) / epsilon, 0.0, 1.0);
       vec3 radiance = light.color * intensity;
       return brdf_contribution(L, V, N, radiance, material);
}

// BRDF contribution for point light
vec3 point_light_contribution(PointLight light, vec3 V, vec3 N, vec3 frag_pos, MaterialData material)
{
       vec3 L = normalize(light.position - frag_pos);
       float d = length(light.position - frag_pos);
       float NoL = max(0.0, dot(N,L));
       float Fatt = 1.0/(light.constant + light.linear_ * d + light.quadratic * d * d);
       vec3 radiance = light.color.rgb * light.intensity * Fatt;
       return brdf_contribution(L, V, N, radiance, material);
}

// Shadow for spot light
vec3 spot_light_shadow(SpotLight light, vec3 frag_color, vec3 frag_pos, float layer)
{
    vec4 shadow_clip = light.view_projection * vec4(frag_pos, 1.0);
    vec4 shadow_coord = vec4(shadow_clip.xyz / shadow_clip.w, shadow_clip.w);
	shadow_coord.st = shadow_coord.st * 0.5 + 0.5;
    shadow_coord.t = 1.0 - shadow_coord.t;

    float shadow_factor = 0.0;
    switch(light.shadow_mode)
    {
        case 0:
            return frag_color;
        case 1:
            return frag_color * sample_shadowmap(ShadowMaps, shadow_coord, layer, vec2(0.0));
        case 2:
            return frag_color * sample_shadowmap_pcf(ShadowMaps, shadow_coord, layer, light.filter_sample, light.filter_scale, light.sample_method);
        case 3:
            return frag_color * sample_shadowmap_pcss(ShadowMaps, shadow_coord, layer, light.filter_scale, light.filter_sample, light.sample_method, light.light_size);
    }

    return frag_color;
}

// Shadow for directional light
vec3 directional_light_shadow(DirectionalLight light, vec3 frag_color, vec3 frag_pos, vec3 view_pos, float layer)
{
    uint cascade_index = 0;
    // Select cascade
    for(uint i = 0; i < 3; ++i)
    {
        if(light.split_depth[i] > view_pos.z)
        {
            cascade_index = i + 1;
        }
    }

    vec4 shadow_clip = light.view_projection[cascade_index] * vec4(frag_pos, 1.0);
    vec4 shadow_coord = vec4(shadow_clip.xyz / shadow_clip.w, shadow_clip.w);
	shadow_coord.st = shadow_coord.st * 0.5 + 0.5;
    shadow_coord.t = 1.0 - shadow_coord.t;

    float shadow_factor = 0.0;
    layer = layer * 4 + cascade_index;
    switch(light.shadow_mode)
    {
        case 0:
            return frag_color;
        case 1:
            return frag_color * sample_shadowmap(CascadeShadowMaps, shadow_coord, layer, vec2(0.0));
        case 2:
            return frag_color * sample_shadowmap_pcf(CascadeShadowMaps, shadow_coord, layer, light.filter_sample, light.filter_scale, light.sample_method);
        case 3:
            return frag_color * sample_shadowmap_pcss(CascadeShadowMaps, shadow_coord, layer, light.filter_scale, light.filter_sample, light.sample_method, light.light_size);
    }

    return frag_color;
}

// Shadow for point light
vec3 point_light_shadow(PointLight light, vec3 frag_color, vec3 frag_pos, float layer)
{
    vec3 L = frag_pos - light.position;
   
    float shadow_factor = 0.0;
    switch(light.shadow_mode)
    {
        case 0:
            return frag_color;
        case 1:
            return frag_color * sample_shadowmap_cube(OmniShadowMaps, L, layer, vec3(0.0));
        case 2:
            return frag_color * sample_shadowmap_cube_pcf(OmniShadowMaps, L, layer, light.filter_scale, light.filter_sample, light.sample_method);
        case 3:
            return frag_color * sample_shadowmap_cube_pcss(OmniShadowMaps, L, layer, light.filter_scale, light.filter_sample, light.sample_method, light.light_size);
    }

    return frag_color;
}

void main()
{
    if(gl_GlobalInvocationID.x > push_data.extent.x || gl_GlobalInvocationID.y > push_data.extent.y)
    {
        return;
    }

    vec2 uv = (vec2(gl_GlobalInvocationID.xy)+vec2(0.5)) / vec2(push_data.extent);

    vec4 gbuffer0 = texture(GBuffer0, uv);
    vec4 gbuffer1 = texture(GBuffer1, uv);
    vec4 gbuffer2 = texture(GBuffer2, uv);
    vec4 gbuffer3 = texture(GBuffer3, uv);
    vec4 gbuffer4 = texture(GBuffer4, uv);
    vec4 gbuffer5 = texture(GBuffer5, uv);
    float depth = texture(DepthBuffer, uv).r;

    // GBuffer 0: RGB - Albedo, A - Anisotropic
	// GBuffer 1: RGB - Normal, A - Linear Depth
	// GBuffer 2: R - Metallic, G - Roughness, B - Subsurface, A - EntityID
	// GBuffer 3: R - Sheen, G - Sheen Tint, B - Clearcoat, A - Clearcoat Gloss
	// GBuffer 4: RG - Velocity, B - Specular, A - Specular Tint
	// GBuffer 5: RGB - Emissive, A - Material Type

    MaterialData material;

    material.base_color = vec4(gbuffer0.rgb, 1.0);
    material.emissive_color = gbuffer5.rgb;
	material.subsurface = gbuffer2.b;
	material.metallic = gbuffer2.r;
	material.specular = gbuffer4.b;
	material.specular_tint = gbuffer4.a;
	material.roughness = clamp(gbuffer2.g, 0.01, 0.99);
	material.anisotropic = gbuffer0.a;
	material.sheen = gbuffer3.r;
	material.sheen_tint = gbuffer3.g;
	material.clearcoat = gbuffer3.b;
	material.clearcoat_gloss = gbuffer3.a;
    material.material_type = uint(gbuffer5.a);

    vec3 normal = gbuffer1.rgb;

    vec3 frag_pos = world_position_from_depth(uv, depth, camera_data.view_inverse * camera_data.projection_inverse);
    vec3 view_pos = (inverse(camera_data.view_inverse) * vec4(frag_pos, 1.0)).xyz;

   vec3 Lo = vec3(0.0);
   vec4 out_color = vec4(0.0, 0.0, 0.0,1.0);
   vec3 V = normalize(camera_data.position - frag_pos);
   vec3 N = normalize(normal);
      
   // Directional light
   for(uint i = 0; i < push_data.directional_light_count; i++)
   {
       Lo += directional_light_shadow(directional_lights[i], direction_light_contribution(directional_lights[i], V, N, frag_pos, material), frag_pos, view_pos, float(i));
   }
   
   // Spot light
   for(uint i = 0; i< push_data.spot_light_count; i++)
   {
        Lo += spot_light_shadow(spot_lights[i], spot_light_contribution(spot_lights[i], V, N, frag_pos, material), frag_pos, float(i));
   }
   
   // Point Light
   for(uint i = 0; i< push_data.point_light_count; i++)
   {
        Lo += point_light_shadow(point_lights[i], point_light_contribution(point_lights[i], V, N, frag_pos, material), frag_pos, float(i));
   }
   
   vec3 color = Lo + material.emissive_color;
   
    imageStore(Lighting, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}
