#version 450

#extension GL_GOOGLE_include_directive: enable

#include "../common.glsl"

#define LUT_SIZE 1024
#define SAMPLE_COUNT 1024

layout (local_size_x = 32, local_size_y = 32) in;

layout (binding = 0, r16f) writeonly uniform image2D Emu_Lut;

vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)
{
    float alpha = roughness * roughness;

    float theta = atan(alpha * sqrt(Xi.x) / sqrt(1 - Xi.x));
    float phi = 2.0 * PI * Xi.y;

    vec3 H = vec3(
        sin(theta)*cos(phi), 
        sin(theta)*sin(phi), 
        cos(theta)
    );

    vec3 Up = N.z > 0.99? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);
    vec3 T = normalize(cross(N, Up));
    vec3 B = normalize(cross(N, T));

    return T * H.x+B * H.y+N * H.z;
}

float GeometrySchlickGGX(float NoV, float roughness)
{
    float alpha = roughness;
    float k = alpha * alpha / 2.0;

    return NoV / (NoV*(1.0 - k) + k);
}

float GeometrySmith(float roughness, float NoV, float NoL)
{
    return GeometrySchlickGGX(NoV, roughness) * GeometrySchlickGGX(NoL, roughness);
}

float IntegrateBRDF(vec3 V, float roughness)
{
    vec3 N = vec3(0.0, 0.0, 1.0);
    float A = 0.0;

    for(uint i = 0; i < SAMPLE_COUNT; i++)
    {
        vec2 Xi = Hammersley(i, SAMPLE_COUNT);
        vec3 H = ImportanceSampleGGX(Xi, N, roughness);
        vec3 L = normalize(H * 2.0 * dot(V, H) - V);

        float NoV = clamp(dot(N, V), 0.0, 1.0);
        float NoL = clamp(dot(N, L), 0.0, 1.0);
        float NoH = clamp(dot(N, H), 0.0, 1.0);
        float VoH = clamp(dot(V, H), 0.0, 1.0);

        float G = GeometrySmith(roughness, NoV, NoL);
        float w = VoH * G / (NoV * NoH);

        A += w;
    }

    return A / SAMPLE_COUNT;
}

void main()
{
    uvec2 uv = gl_GlobalInvocationID.xy;
    float step = 1.0 / LUT_SIZE;

    float roughness = step * (uv.y + 0.5);
    float NoV = step * (uv.x + 0.5);
    vec3 V = vec3(sqrt(1.0 - NoV * NoV), 0.0, NoV);

    imageStore(Emu_Lut, ivec2(uv), vec4(IntegrateBRDF(V, roughness)));
}