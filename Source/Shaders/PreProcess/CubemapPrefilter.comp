#version 450

#extension GL_KHR_vulkan_glsl : enable

#include "../GlobalBuffer.glsl"
#include "../GlobalFunction.glsl"

// Cubemap Direction
#define POSITIVE_X 0
#define NEGATIVE_X 1
#define POSITIVE_Y 2
#define NEGATIVE_Y 3
#define POSITIVE_Z 4
#define NEGATIVE_Z 5

#define LOCAL_SIZE 8

#define SAMPLE_COUNT 4096

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba16f) uniform imageCube PrefilterMap;
layout(set = 0, binding = 1) uniform samplerCube Skybox;

layout(push_constant) uniform PushBlock{
	uvec2 mip_extent;
	float roughness;
}push_data;

vec3 calculate_direction(uint face_idx, uint face_x, uint face_y)
{
	float u = 2.0 * (float(face_x) + 0.5) / float(push_data.mip_extent.x) - 1.0;
	float v = 2.0 * (float(face_y) + 0.5) / float(push_data.mip_extent.y) - 1.0;
	float x, y, z;

	switch(face_idx)
	{
		case POSITIVE_X:
			x = 1;
			y = -v;
			z = -u;
			break;
		case NEGATIVE_X:
			x = -1;
			y = -v;
			z = u;
			break;
		case POSITIVE_Y:
			x = u;
			y = 1;
			z = v;
			break;
		case NEGATIVE_Y:
			x = u;
			y = -1;
			z =  -v;
			break;
		case POSITIVE_Z:
			x = u;
			y = -v;
			z = 1;
			break;
		case NEGATIVE_Z:
			x = -u;
			y = -v;
			z = -1;
			break;
	}
	
	return normalize(vec3(x, y, z));
}

vec3 GGX_importance_sampling(vec2 Xi, vec3 N, float roughness)
{
    float alpha = roughness * roughness;

    float theta = atan(alpha * sqrt(Xi.x) / sqrt(1 - Xi.x));
    float phi = 2.0 * PI * Xi.y;

    vec3 H = vec3(
        sin(theta)*cos(phi), 
        sin(theta)*sin(phi), 
        cos(theta)
    );

    vec3 Up = N.z > 0.99? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);
    vec3 T = normalize(cross(N, Up));
    vec3 B = normalize(cross(N, T));

    return T * H.x+B * H.y+N * H.z;
}

void main()
{
	vec3 N = calculate_direction(gl_GlobalInvocationID.z, gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	vec3 R = N;
	vec3 V = R;

	ivec2 size = textureSize(Skybox, 0);
	float resolution = float(size.x);

	vec3 prefilter_color = vec3(0.0);
	float total_weight = 0.0;

	for(uint i = 0; i < SAMPLE_COUNT; i++)
	{
		vec2 Xi = Hammersley(i, SAMPLE_COUNT);
		vec3 H = GGX_importance_sampling(Xi, N, push_data.roughness);
		vec3 L = normalize(2.0 * dot(V, H) * H - V);

		float NoL = max(dot(N, L), 0.0);
		if(NoL > 0.0)
		{
			prefilter_color += texture(Skybox, L).rgb * NoL;
			total_weight += NoL;
		}
	}

	prefilter_color /= total_weight;

	imageStore(PrefilterMap, ivec3(gl_GlobalInvocationID.xyz), vec4(prefilter_color, 1.0));
}