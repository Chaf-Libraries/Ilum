#version 450
layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct Instance
{
    mat4 transform;
    mat4 last_transform;
    vec3 bbox_min;
    uint entity_id;
    vec3 bbox_max;
    uint material_id;
    uint vertex_offset;
    uint index_offset;
    uint index_count;
};

struct DrawIndexedIndirectCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

struct CountInfo
{
    uint actual_draw;
    uint total_draw;
    uint meshlet_visible_count;
    uint instance_visible_count;
    uint meshlet_invisible_count;
    uint instance_invisible_count;
    uint meshlet_total_count;
    uint instance_total_count;
};

struct CSParam
{
    uvec3 DispatchThreadID;
};

layout(set = 0, binding = 0, std430) readonly buffer type_StructuredBuffer_Instance
{
   Instance _m0[];
} instances;

layout(set = 0, binding = 1, std430) buffer type_RWStructuredBuffer_uint
{
    uint _m0[];
} visibilities;

layout(set = 0, binding = 7, std430) buffer type_ACSBuffer_counter
{
    int counter;
} counter_var_visibilities;

layout(set = 0, binding = 2, std140) uniform type_ConstantBuffer_Camera
{
   mat4 view_projection;
   mat4 last_view_projection;
   mat4 inverse_view;
   mat4 inverse_projection;
    vec4 frustum[6];
    vec3 position;
    uint frame_count;
} camera;

layout(set = 0, binding = 3, std430) buffer type_RWStructuredBuffer_DrawIndexedIndirectCommand
{
    DrawIndexedIndirectCommand _m0[];
} indirect_draws;

layout(set = 0, binding = 8, std430) buffer counter_var_indirect_draws
{
    int counter;
} counter_var_indirect_draws_1;

layout(set = 0, binding = 4, std140) uniform type_ConstantBuffer_CullingInfo
{
   mat4 view;
   mat4 last_view;
    float P00;
    float P11;
    float znear;
    float zfar;
    float zbuffer_width;
    float zbuffer_height;
    uint meshlet_count;
    uint instance_count;
} culling_info;

layout(set = 0, binding = 5, std430) buffer type_RWStructuredBuffer_CountInfo
{
    CountInfo _m0[];
} count_info;

layout(set = 0, binding = 9, std430) buffer counter_var_count_info
{
    int counter;
} counter_var_count_info_1;

layout(set = 0, binding = 6, std430) buffer draw_info
{
    uint _m0[];
} draw_info_1;

layout(set = 0, binding = 10, std430) buffer counter_var_draw_info
{
    int counter;
} counter_var_draw_info_1;

layout(push_constant, std430) uniform type_PushConstant_
{
    uint enable_frustum_culling;
} push_constants;

bool CheckSphere(vec3 pos, float radius)
{
    for (uint i = 0u; i < 6u; i++)
    {
        if ((dot(camera.frustum[i], vec4(pos, 1.0)) + radius) < 0.0)
        {
            return false;
        }
    }
    return true;
}

bool CheckFrustum(Instance instance)
{
    vec3 min_val = instance.bbox_min;
    vec3 max_val = instance.bbox_max;
    vec3 pos = (min_val + max_val) / vec3(2.0);
    float radius = length(min_val - max_val) / 2.0;
    vec3 param_var_pos = pos;
    float param_var_radius = radius;
    if (CheckSphere(param_var_pos, param_var_radius))
    {
        return true;
    }
    else
    {
        for (uint i = 0u; i < 6u; i++)
        {
            vec4 plane = camera.frustum[i];
            vec3 plane_normal = vec3(plane.x, plane.y, plane.z);
            float plane_constant = plane.w;
            vec3 axis_vert = vec3(0.0);
            axis_vert.x = (plane.x < 0.0) ? min_val.x : max_val.x;
            axis_vert.y = (plane.y < 0.0) ? min_val.y : max_val.y;
            axis_vert.z = (plane.z < 0.0) ? min_val.z : max_val.z;
            if ((dot(axis_vert, plane_normal) + plane_constant) > 0.0)
            {
                return false;
            }
        }
    }
    return true;
}

void src_main(CSParam param)
{
    uint idx = param.DispatchThreadID.x;
    uint temp = 0u;
    if (idx == 0u)
    {
        uint _117 = atomicExchange(count_info._m0[0u].instance_visible_count, 0u);
        temp = _117;
        uint _119 = atomicExchange(count_info._m0[0u].instance_invisible_count, 0u);
        temp = _119;
        uint _121 = atomicExchange(count_info._m0[0u].instance_total_count, 0u);
        temp = _121;
        uint _123 = atomicExchange(count_info._m0[0u].actual_draw, 0u);
        temp = _123;
        uint _125 = atomicExchange(count_info._m0[0u].total_draw, 0u);
        temp = _125;
    }
    if (idx >= culling_info.instance_count)
    {
        return;
    }
    Instance instance = Instance(instances._m0[idx].transform, instances._m0[idx].last_transform, instances._m0[idx].bbox_min, instances._m0[idx].entity_id, instances._m0[idx].bbox_max, instances._m0[idx].material_id, instances._m0[idx].vertex_offset, instances._m0[idx].index_offset, instances._m0[idx].index_count);
    mat4 trans = (instance.transform);
    vec3 xa = trans[0u].xyz * instance.bbox_min.x;
    vec3 xb = trans[0u].xyz * instance.bbox_max.x;
    vec3 ya = trans[1u].xyz * instance.bbox_min.y;
    vec3 yb = trans[1u].xyz * instance.bbox_max.y;
    vec3 za = trans[2u].xyz * instance.bbox_min.z;
    vec3 zb = trans[2u].xyz * instance.bbox_max.z;
    vec3 new_min_ = trans[3u].xyz;
    new_min_ += min(xa, xb);
    new_min_ += min(ya, yb);
    new_min_ += min(za, zb);
    vec3 new_max_ = trans[3u].xyz;
    new_max_ += max(xa, xb);
    new_max_ += max(ya, yb);
    new_max_ += max(za, zb);
    instance.bbox_min = new_min_;
    instance.bbox_max = new_max_;
    bool visible = true;
    if (push_constants.enable_frustum_culling == 1u)
    {
        Instance param_var_instance = instance;
        visible = CheckFrustum(param_var_instance);
    }
    if (visible)
    {
        uint _242 = atomicAdd(count_info._m0[0u].instance_visible_count, 1u);
        uint dci = _242;
        indirect_draws._m0[dci].indexCount = instance.index_count;
        indirect_draws._m0[dci].instanceCount = 1u;
        indirect_draws._m0[dci].firstIndex = instance.index_offset;
        indirect_draws._m0[dci].vertexOffset = int(instance.vertex_offset);
        indirect_draws._m0[dci].firstInstance = idx;
        draw_info_1._m0[dci] = idx;
        visibilities._m0[idx] = 1u;
        uint _268 = atomicAdd(count_info._m0[0u].actual_draw, 1u);
        temp = _268;
    }
    else
    {
        uint _270 = atomicAdd(count_info._m0[0u].instance_invisible_count, 1u);
        uint dci_1 = _270;
        indirect_draws._m0[(culling_info.instance_count - 1u) - dci_1].indexCount = instance.index_count;
        indirect_draws._m0[(culling_info.instance_count - 1u) - dci_1].instanceCount = 1u;
        indirect_draws._m0[(culling_info.instance_count - 1u) - dci_1].firstIndex = instance.index_offset;
        indirect_draws._m0[(culling_info.instance_count - 1u) - dci_1].vertexOffset = int(instance.vertex_offset);
        indirect_draws._m0[(culling_info.instance_count - 1u) - dci_1].firstInstance = idx;
        draw_info_1._m0[(culling_info.instance_count - 1u) - dci_1] = idx;
        visibilities._m0[idx] = 0u;
    }
    uint _319 = atomicAdd(count_info._m0[0u].instance_total_count, 1u);
    temp = _319;
    uint _321 = atomicAdd(count_info._m0[0u].total_draw, 1u);
    temp = _321;
}

void main()
{
    CSParam param_var_param = CSParam(gl_GlobalInvocationID);
    src_main(param_var_param);
}

