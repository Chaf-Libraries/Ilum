#version 450

#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define DBL_MAX 1.7976931348623158e+308
#define DBL_MIN 2.2250738585072014e-308

struct Bound 
{
	vec3 center;
    float radius;
    vec3 cone_apex;
    float cone_cutoff;
    vec3 cone_axis;
};

struct DrawIndexedIndirectCommand 
{
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
};

struct TransformData
{
    mat4 world_transform;
    mat4 pre_transform;
};

layout (binding = 0) buffer Bounding
{
   Bound bounds[ ];
};

layout (binding = 1, std430) buffer IndirectDraws
{
	DrawIndexedIndirectCommand indirectDraws[ ];
};

layout (binding = 2) buffer Transform
{
    TransformData transform[];
};

layout (binding = 3) uniform Camera 
{
	mat4 view_projection;
    vec4 frustum[6];
    vec3 position;
} camera;

layout (binding = 4) buffer Meshlet
{
    uint meshlet[];
};

layout (local_size_x = 256) in;

bool checkBound(Bound bound)
{


    for (uint i = 0; i < 6; i++)
    {
        if (dot(camera.frustum[i], vec4(bound.center, 1)) + length(bound.radius) < 0.0)
        {
            return false;
        }
    }
    return true;
}


void main()
{
	uint idx = gl_GlobalInvocationID.x;

    Bound bound = bounds[idx];
    mat4 trans = transform[meshlet[idx]].world_transform * transform[meshlet[idx]].pre_transform;

    bound.center = (trans * vec4(bound.center, 1.0)).xyz;
    vec3 edge = vec3(1.0) * sqrt(bound.radius * bound.radius / 3.0);
    bound.radius = length(vec3(
        abs(trans[0][0])*edge.x + abs(trans[0][1])*edge.y + abs(trans[0][2])*edge.z,
        abs(trans[1][0])*edge.x + abs(trans[1][1])*edge.y + abs(trans[1][2])*edge.z,
        abs(trans[2][0])*edge.x + abs(trans[2][1])*edge.y + abs(trans[2][2])*edge.z
    ));

    vec3 scale = vec3(
        sqrt(trans[0][0] * trans[0][0] + trans[0][1] * trans[0][1] + trans[0][2] * trans[0][2]),
        sqrt(trans[1][0] * trans[1][0] + trans[1][1] * trans[1][1] + trans[1][2] * trans[1][2]),
        sqrt(trans[2][0] * trans[2][0] + trans[2][1] * trans[2][1] + trans[2][2] * trans[2][2])
    );

    mat3 rotation = mat3(
        trans[0].xyz/scale.x,
        trans[1].xyz/scale.y,
        trans[2].xyz/scale.z
    );

    bound.cone_apex = (trans * vec4(bound.cone_apex, 1.0)).xyz;
    bound.cone_axis = rotation * bound.cone_axis;

    if (dot(normalize(camera.position - bound.cone_apex), bound.cone_axis) < bound.cone_cutoff && checkBound(bound))
    {
        indirectDraws[idx].instanceCount = 1;
    }
    else
    {
        indirectDraws[idx].instanceCount = 0;
    }
}