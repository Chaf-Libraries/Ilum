#version 450

layout (local_size_x = 256) in;

#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define DBL_MAX 1.7976931348623158e+308
#define DBL_MIN 2.2250738585072014e-308

const float infinity = 1. / 0.;

struct Bound 
{
	vec3 center;
    float radius;
    vec3 cone_apex;
    float cone_cutoff;
    vec3 cone_axis;
};

struct DrawIndexedIndirectCommand 
{
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
};

struct TransformData
{
    mat4 world_transform;
    mat4 pre_transform;
};

layout (binding = 0) buffer Bounding
{
   Bound bounds[ ];
};

layout (binding = 1, std430) buffer IndirectDraws
{
	DrawIndexedIndirectCommand indirectDraws[ ];
};

layout (binding = 2) buffer Transform
{
    TransformData transform[];
};

layout (binding = 3) uniform Camera 
{
	mat4 view_projection;
    vec4 frustum[6];
    vec3 position;
    mat4 last_view_projection;
} camera;

layout (binding = 4) buffer Meshlet
{
    uint meshlet[];
};

layout (binding = 5) uniform sampler2D hiz_buffer;

layout (binding = 6) buffer MeshletCount
{
    uint count;
};

layout(push_constant) uniform PushConstBlock {
    mat4 view;
    mat4 last_view;
    float P00;
    float P11;
    float znear;
    float zfar;
    float zbuffer_width;
    float zbuffer_height;
    uint draw_count;
    uint frustum_enable;
    uint backface_enable;
    uint occlusion_enable;
} cullData;


bool checkFrustum(Bound bound)
{
    for (uint i = 0; i < 6; i++)
    {
        if (dot(camera.frustum[i], vec4(bound.center, 1)) + length(bound.radius) < 0.0)
        {
            return false;
        }
    }
    return true;
}

bool projectSphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb)
{
    if (C.z < r + znear)
		return false;

	vec2 cx = -C.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -C.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r);
	vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

	aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);
	aabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f); // clip space -> uv space

    return true;
}

bool checkOcclusion(Bound bound)
{
    vec3 dir = normalize(camera.position - bound.center);
    vec4 sceen_space_center_last = camera.last_view_projection * vec4(bound.center + dir*bound.radius, 1.0);

    vec3 C = ((cullData.view) * vec4(bound.center,1.0)).xyz;
    C.z=-C.z;

    vec4 aabb;
    if(!projectSphere(C, bound.radius, cullData.znear, cullData.P00, cullData.P11, aabb))
    {
        return true;
    }

    float width = (aabb.z - aabb.x) * cullData.zbuffer_width;
    float height = (aabb.w - aabb.y) * cullData.zbuffer_height;

    float mip_level = floor(log2(max(width, height))) - 1;

    vec2 uv = (aabb.xy + aabb.zw) * 0.5;
    vec2 uv0 = aabb.xy;
    vec2 uv1 = aabb.zw;
    vec2 uv2 = aabb.xw;
    vec2 uv3 = aabb.zy;

    float depth = textureLod(hiz_buffer, uv, mip_level).r;
    depth = max(depth, textureLod(hiz_buffer, uv0, mip_level).r);
    depth = max(depth, textureLod(hiz_buffer, uv1, mip_level).r);
    depth = max(depth, textureLod(hiz_buffer, uv2, mip_level).r);
    depth = max(depth, textureLod(hiz_buffer, uv3, mip_level).r);
    
    return depth >= abs(sceen_space_center_last.z) - bound.radius;
}


void main()
{
	uint idx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;

    if (idx == 0)
	{
		atomicExchange(count, 0);
	}

    Bound bound = bounds[indirectDraws[idx].firstInstance];
    mat4 trans = transform[meshlet[indirectDraws[idx].firstInstance]].world_transform * transform[meshlet[indirectDraws[idx].firstInstance]].pre_transform;
    bound.center = (trans * vec4(bound.center, 1.0)).xyz;
    vec3 edge = vec3(1.0) * sqrt(bound.radius * bound.radius / 3.0);
    bound.radius = length(vec3(
        abs(trans[0][0])*edge.x + abs(trans[0][1])*edge.y + abs(trans[0][2])*edge.z,
        abs(trans[1][0])*edge.x + abs(trans[1][1])*edge.y + abs(trans[1][2])*edge.z,
        abs(trans[2][0])*edge.x + abs(trans[2][1])*edge.y + abs(trans[2][2])*edge.z
    ));

    bool visible = true;

    if(visible && cullData.frustum_enable == 1)
    {
        visible = visible && checkFrustum(bound);
    }

    if(visible && cullData.backface_enable == 1)
    {
        vec3 scale = vec3(
            sqrt(trans[0][0] * trans[0][0] + trans[0][1] * trans[0][1] + trans[0][2] * trans[0][2]),
            sqrt(trans[1][0] * trans[1][0] + trans[1][1] * trans[1][1] + trans[1][2] * trans[1][2]),
            sqrt(trans[2][0] * trans[2][0] + trans[2][1] * trans[2][1] + trans[2][2] * trans[2][2])
        );

        mat3 rotation = mat3(
            trans[0].xyz/scale.x,
            trans[1].xyz/scale.y,
            trans[2].xyz/scale.z
        );

        bound.cone_apex = (trans * vec4(bound.cone_apex, 1.0)).xyz;
        bound.cone_axis = rotation * bound.cone_axis;

        visible = visible && dot(normalize(camera.position - bound.cone_apex), bound.cone_axis) < bound.cone_cutoff;
    }

    if(visible && cullData.occlusion_enable == 1)
    {
        visible = visible && checkOcclusion(bound);
    }

    if (visible)
    {
        indirectDraws[idx].instanceCount = 1;
        atomicAdd(count, 1);
    }
    else
    {
        indirectDraws[idx].instanceCount = 0;
    }
    

    // Bound bound = bounds[indirectDraws[idx].firstInstance];
    // mat4 trans = transform[meshlet[indirectDraws[idx].firstInstance]].world_transform * transform[meshlet[indirectDraws[idx].firstInstance]].pre_transform;

    // bound.center = (trans * vec4(bound.center, 1.0)).xyz;
    // vec3 edge = vec3(1.0) * sqrt(bound.radius * bound.radius / 3.0);
    // bound.radius = length(vec3(
    //     abs(trans[0][0])*edge.x + abs(trans[0][1])*edge.y + abs(trans[0][2])*edge.z,
    //     abs(trans[1][0])*edge.x + abs(trans[1][1])*edge.y + abs(trans[1][2])*edge.z,
    //     abs(trans[2][0])*edge.x + abs(trans[2][1])*edge.y + abs(trans[2][2])*edge.z
    // ));

    // vec3 scale = vec3(
    //     sqrt(trans[0][0] * trans[0][0] + trans[0][1] * trans[0][1] + trans[0][2] * trans[0][2]),
    //     sqrt(trans[1][0] * trans[1][0] + trans[1][1] * trans[1][1] + trans[1][2] * trans[1][2]),
    //     sqrt(trans[2][0] * trans[2][0] + trans[2][1] * trans[2][1] + trans[2][2] * trans[2][2])
    // );

    // mat3 rotation = mat3(
    //     trans[0].xyz/scale.x,
    //     trans[1].xyz/scale.y,
    //     trans[2].xyz/scale.z
    // );

    // bound.cone_apex = (trans * vec4(bound.cone_apex, 1.0)).xyz;
    // bound.cone_axis = rotation * bound.cone_axis;

    // if (checkFrustum(bound)
    //     && dot(normalize(camera.position - bound.cone_apex), bound.cone_axis) < bound.cone_cutoff 
    //     && checkOcclusion(bound, idx))
    // {
    //     indirectDraws[idx].instanceCount = 1;
    //     atomicAdd(count, 1);
    // }
    // else
    // {
    //     indirectDraws[idx].instanceCount = 0;
    // }
}