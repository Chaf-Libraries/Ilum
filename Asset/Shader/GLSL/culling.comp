#version 450

#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define DBL_MAX 1.7976931348623158e+308
#define DBL_MIN 2.2250738585072014e-308

struct AABB 
{
	vec3 min_;
    vec3 max_;
};

struct DrawIndexedIndirectCommand 
{
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
};

layout (binding = 0) buffer BoundingBox 
{
   AABB boundingbox[ ];
};

layout (binding = 1, std430) buffer IndirectDraws
{
	DrawIndexedIndirectCommand indirectDraws[ ];
};

layout (binding = 2) buffer Transform
{
    mat4 transform[];
};

layout (binding = 3) uniform Camera 
{
	mat4 view_projection;
    vec4 frustum[6];
    vec3 position;
} camera;

layout (local_size_x = 16) in;

bool checkSphere(vec3 pos, float radius)
{
    for (uint i = 0; i < 6; i++)
    {
        if (dot(camera.frustum[i], vec4(pos, 1)) + radius < 0.0)
        {
            return false;
        }
    }
    return true;
}

AABB boundingBoxTransform(AABB aabb, mat4 trans)
{
    vec3 center = (aabb.min_ + aabb.max_) / 2.0;
    vec3 new_center = (trans * vec4(center, 1.0)).xyz;
    vec3 old_edge = (aabb.max_ - aabb.min_) / 2.0;
    vec3 new_edge = {
        abs(trans[0][0])*old_edge.x + abs(trans[0][1])*old_edge.y + abs(trans[0][2])*old_edge.z,
        abs(trans[1][0])*old_edge.x + abs(trans[1][1])*old_edge.y + abs(trans[1][2])*old_edge.z,
        abs(trans[2][0])*old_edge.x + abs(trans[2][1])*old_edge.y + abs(trans[2][2])*old_edge.z
    };

    AABB new_aabb;
    new_aabb.min_ = new_center - new_edge;
    new_aabb.max_ = new_center + new_edge;

    return new_aabb;
}

// Frustum Culling for AABB
bool checkAABB(AABB aabb)
{
    vec3 min_val = aabb.min_;
    vec3 max_val = aabb.max_;

	vec3 pos = (min_val + max_val)/2.0;
	float radius = length(min_val - max_val)/2.0;
    if(checkSphere(pos, radius))
    {
        return true;
    }
    else
    {
        for (uint i=0; i < 6; i++)
        {
            vec4 plane = camera.frustum[i];
            vec3 plane_normal = { plane.x, plane.y, plane.z };
            float plane_constant = plane.w;

            vec3 axis_vert = { 0.0, 0.0, 0.0 };

            // x-axis
            axis_vert.x = plane.x < 0.0 ? min_val.x : max_val.x;

            // y-axis
            axis_vert.y = plane.y < 0.0 ? min_val.y : max_val.y;

            // z-axis
            axis_vert.z = plane.z < 0.0 ? min_val.z : max_val.z;

            if (dot(axis_vert, plane_normal) + plane_constant > 0.0)
            {
                return false;
            }
        }
    }
    
    return true;
}

void main()
{
	uint idx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;

    AABB aabb = boundingbox[indirectDraws[idx].firstInstance];
    mat4 trans = transform[indirectDraws[idx].firstInstance];

    if (checkAABB(boundingBoxTransform(aabb, trans)))
    {
        indirectDraws[idx].instanceCount = 1;
    }
    else
    {
        indirectDraws[idx].instanceCount = 0;
    }
}