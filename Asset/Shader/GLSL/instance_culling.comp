#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define DBL_MAX 1.7976931348623158e+308
#define DBL_MIN 2.2250738585072014e-308

const float infinity = 1. / 0.;

struct PerInstanceData
{
	mat4 world_transform;
	mat4 pre_transform;

	vec3 bbox_min;
	uint entity_id;

	vec3 bbox_max;
};

layout (binding = 0) buffer PerInstanceBuffer
{
    PerInstanceData instance_data[];
};

layout (binding = 1) buffer VisibilityBuffer
{
    uint visibility_data[];
};

layout (binding = 2) uniform Camera 
{
    mat4 view_projection;
	mat4 last_view_projection;
	vec4 frustum[6];
	vec3 position;
} camera;

layout (binding = 3) uniform sampler2D hiz_buffer;

layout(binding = 4) uniform CullingBuffer {
    mat4 view;

    mat4 last_view;

    float P00;
    float P11;
    float znear;
    float zfar;

    float zbuffer_width;
    float zbuffer_height;
    uint frustum_enable;
    uint backface_enable;
    
    uint occlusion_enable;
    uint meshlet_count;
    uint instance_count;
} cullData;

layout (binding = 5) buffer CountBuffer
{
    uint visible_count;
    uint instance_visible_count;
    uint invisible_count;
    uint total_count;
};

bool checkSphere(vec3 pos, float radius)
{
    for (uint i = 0; i < 6; i++)
    {
        if (dot(camera.frustum[i], vec4(pos, 1)) + radius < 0.0)
        {
            return false;
        }
    }
    return true;
}

bool checkFrustum(PerInstanceData instance)
{
    vec3 min_val = instance.bbox_min;
    vec3 max_val = instance.bbox_max;

	vec3 pos = (min_val + max_val)/2.0;
	float radius = length(min_val - max_val)/2.0;
    if(checkSphere(pos, radius))
    {
        return true;
    }
    else
    {
        for (uint i=0; i < 6; i++)
        {
            vec4 plane = camera.frustum[i];
            vec3 plane_normal = { plane.x, plane.y, plane.z };
            float plane_constant = plane.w;

            vec3 axis_vert = { 0.0, 0.0, 0.0 };

            // x-axis
            axis_vert.x = plane.x < 0.0 ? min_val.x : max_val.x;

            // y-axis
            axis_vert.y = plane.y < 0.0 ? min_val.y : max_val.y;

            // z-axis
            axis_vert.z = plane.z < 0.0 ? min_val.z : max_val.z;

            if (dot(axis_vert, plane_normal) + plane_constant > 0.0)
            {
                return false;
            }
        }
    }

    return true;
}

void main()
{
	uint idx = gl_GlobalInvocationID.x;

    if (idx == 0)
	{
		atomicExchange(instance_visible_count, 0);
	}

    if(idx >= cullData.instance_count)
    {
        return;
    }

    PerInstanceData instance = instance_data[idx];

    mat4 trans = instance_data[idx].world_transform * instance_data[idx].pre_transform;

    vec3 new_min_, new_max_, xa, xb, ya, yb, za, zb;

	xa = trans[0].xyz * instance.bbox_min[0];
	xb = trans[0].xyz * instance.bbox_max[0];

	ya = trans[1].xyz * instance.bbox_min[1];
	yb = trans[1].xyz * instance.bbox_max[1];

	za = trans[2].xyz * instance.bbox_min[2];
	zb = trans[2].xyz * instance.bbox_max[2];

	new_min_ = trans[3].xyz;
	new_min_ += min(xa, xb);
	new_min_ += min(ya, yb);
	new_min_ += min(za, zb);

	new_max_ = trans[3].xyz;
	new_max_ += max(xa, xb);
	new_max_ += max(ya, yb);
	new_max_ += max(za, zb);

    instance.bbox_min = new_min_;
    instance.bbox_max = new_max_;

    bool visible = true;

    if(visible && cullData.frustum_enable == 1)
    {
        visible = visible && checkFrustum(instance);
    }
    
    if (visible)
    {
        visibility_data[idx] = 1;
        atomicAdd(instance_visible_count, 1);
    }
    else
    {
        visibility_data[idx] = 0;
    }
}