#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define DBL_MAX 1.7976931348623158e+308
#define DBL_MIN 2.2250738585072014e-308

const float infinity = 1. / 0.;

struct PerInstanceData
{
	// Transform
	mat4 world_transform;
	mat4 pre_transform;

	// Material
	vec4 base_color;
	vec3 emissive_color;
	float metallic_factor;

	float roughness_factor;
	float emissive_intensity;
	uint albedo_map;
	uint normal_map;

	uint metallic_map;
	uint roughness_map;
	uint emissive_map;
	uint ao_map;

	vec3 min_;
	float displacement_height;

    vec3 max_;
	uint displacement_map;
};

layout (binding = 0) buffer PerInstanceBuffer
{
    PerInstanceData instance_data[];
};

layout (binding = 1) buffer VisibilityBuffer
{
    uint visibility_data[];
};

layout (binding = 2) uniform Camera 
{
	mat4 view_projection;
    vec4 frustum[6];
    vec3 position;
    mat4 last_view_projection;
} camera;

layout (binding = 3) uniform sampler2D hiz_buffer;

layout(binding = 4) uniform CullingBuffer {
    mat4 view;
    mat4 last_view;
    float P00;
    float P11;
    float znear;
    float zfar;
    float zbuffer_width;
    float zbuffer_height;
    uint draw_count;
    uint frustum_enable;
    uint backface_enable;
    uint occlusion_enable;
} cullData;

layout (binding = 5) buffer CountBuffer
{
    uint visible_count;
    uint instance_visible_count;
    uint invisible_count;
    uint total_count;
};

bool checkSphere(vec3 pos, float radius)
{
    for (uint i = 0; i < 6; i++)
    {
        if (dot(camera.frustum[i], vec4(pos, 1)) + radius < 0.0)
        {
            return false;
        }
    }
    return true;
}

bool checkFrustum(PerInstanceData instance)
{
    vec3 min_val = instance.min_;
    vec3 max_val = instance.max_;

	vec3 pos = (min_val + max_val)/2.0;
	float radius = length(min_val - max_val)/2.0;
    if(checkSphere(pos, radius))
    {
        return true;
    }
    else
    {
        for (uint i=0; i < 6; i++)
        {
            vec4 plane = camera.frustum[i];
            vec3 plane_normal = { plane.x, plane.y, plane.z };
            float plane_constant = plane.w;

            vec3 axis_vert = { 0.0, 0.0, 0.0 };

            // x-axis
            axis_vert.x = plane.x < 0.0 ? min_val.x : max_val.x;

            // y-axis
            axis_vert.y = plane.y < 0.0 ? min_val.y : max_val.y;

            // z-axis
            axis_vert.z = plane.z < 0.0 ? min_val.z : max_val.z;

            if (dot(axis_vert, plane_normal) + plane_constant > 0.0)
            {
                return false;
            }
        }
    }

    return true;
}

bool projectSphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb)
{
    if (C.z < r + znear)
		return false;

	vec2 cx = -C.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -C.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r);
	vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

	aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);
	aabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f); // clip space -> uv space

    return true;
}

float LinearizeDepth(float depth)
{
  float d =  (2.0 * cullData.znear) / (cullData.zfar + cullData.znear - depth * (cullData.zfar - cullData.znear));	
  return cullData.znear + d*(cullData.zfar - cullData.znear);
}

bool checkOcclusion(PerInstanceData instance)
{
    vec3 min_val = instance.min_;
    vec3 max_val = instance.max_;

    vec3 center = (min_val + max_val)/2.0;
	float radius = length(min_val - max_val)/2.0;

    vec3 dir = normalize(camera.position - center);
    vec4 sceen_space_center_last = camera.last_view_projection * vec4(center + dir*radius, 1.0);

    vec3 C = ((cullData.view) * vec4(center,1.0)).xyz;
    C.z=-C.z;

    vec4 aabb;
    if(!projectSphere(C, radius, cullData.znear, cullData.P00, cullData.P11, aabb))
    {
        return true;
    }

    float width = (aabb.z - aabb.x) * cullData.zbuffer_width;
    float height = (aabb.w - aabb.y) * cullData.zbuffer_height;

    float mip_level = floor(log2(max(width, height))) - 1;

    vec2 uv = (aabb.xy + aabb.zw) * 0.5;
    vec2 uv0 = aabb.xy;
    vec2 uv1 = aabb.zw;
    vec2 uv2 = aabb.xw;
    vec2 uv3 = aabb.zy;

    float depth = textureLod(hiz_buffer, uv, mip_level).r;
    depth = max(depth, textureLod(hiz_buffer, uv0, mip_level).r);
    depth = max(depth, textureLod(hiz_buffer, uv1, mip_level).r);
    depth = max(depth, textureLod(hiz_buffer, uv2, mip_level).r);
    depth = max(depth, textureLod(hiz_buffer, uv3, mip_level).r);
    
    float depthSphere = abs(sceen_space_center_last.z);

    return LinearizeDepth(depth) >= depthSphere;
}

void main()
{
	uint idx = gl_GlobalInvocationID.x;

    if (idx == 0)
	{
		atomicExchange(instance_visible_count, 0);
	}

    if(idx >= cullData.draw_count)
    {
        return;
    }

    PerInstanceData instance = instance_data[idx];

    mat4 trans = instance_data[idx].world_transform * instance_data[idx].pre_transform;

    vec3 center = (instance.min_ + instance.max_) / 2.0;
    vec3 new_center = (trans * vec4(center, 1.0)).xyz;
    vec3 old_edge = (instance.max_ - instance.min_) / 2.0;
    vec3 new_edge = {
        abs(trans[0][0])*old_edge.x + abs(trans[0][1])*old_edge.y + abs(trans[0][2])*old_edge.z,
        abs(trans[1][0])*old_edge.x + abs(trans[1][1])*old_edge.y + abs(trans[1][2])*old_edge.z,
        abs(trans[2][0])*old_edge.x + abs(trans[2][1])*old_edge.y + abs(trans[2][2])*old_edge.z
    };

    instance.min_ = new_center - new_edge;
    instance.max_ = new_center + new_edge;

    bool visible = true;

    if(visible && cullData.frustum_enable == 1)
    {
        visible = visible && checkFrustum(instance);
    }

    if(visible && cullData.occlusion_enable == 1)
    {
        visible = visible && checkOcclusion(instance);
    }

    if (visible)
    {
        visibility_data[idx] = 1;
        atomicAdd(instance_visible_count, 1);
    }
    else
    {
        visibility_data[idx] = 0;
    }
}