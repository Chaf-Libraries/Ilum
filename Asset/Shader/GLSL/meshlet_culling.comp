#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define DBL_MAX 1.7976931348623158e+308
#define DBL_MIN 2.2250738585072014e-308

const float infinity = 1. / 0.;

struct PerInstanceData
{
	// Transform
	mat4 world_transform;
	mat4 pre_transform;

	// Material
	vec4 base_color;
	vec3 emissive_color;
	float metallic_factor;

	float roughness_factor;
	float emissive_intensity;
	uint albedo_map;
	uint normal_map;

	uint metallic_map;
	uint roughness_map;
	uint emissive_map;
	uint ao_map;

	vec3 min_;
	float displacement_height;

    vec3 max_;
	uint displacement_map;
};

struct PerMeshletData
{
	// Vertex
	uint instance_id;
	uint vertex_offset;
	uint index_offset;
	uint index_count;

	vec3 center;
	float radius;

	vec3 cone_apex;
	float cone_cutoff;

	vec3 cone_axis;
};

struct DrawIndexedIndirectCommand 
{
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int vertexOffset;
	uint firstInstance;
};

layout (binding = 0, std430) buffer IndirectDraws
{
	DrawIndexedIndirectCommand indirectDraws[ ];
};

layout (binding = 1) buffer PerInstanceBuffer
{
    PerInstanceData instance_data[];
};

layout (binding = 2) buffer PerMeshletBuffer
{
    PerMeshletData meshlet_data[];
};

layout (binding = 3) buffer DrawBuffer
{
    uint draw_data[];
};

layout (binding = 4) uniform Camera 
{
	mat4 view_projection;
    vec4 frustum[6];
    vec3 position;
    mat4 last_view_projection;
} camera;


layout (binding = 5) uniform sampler2D hiz_buffer;

layout (binding = 6) buffer MeshletCount
{
    uint visible_count;
    uint instance_visible_count;
    uint invisible_count;
    uint total_count;
};

layout(binding = 7) uniform CullingBuffer {
    mat4 view;

    mat4 last_view;

    float P00;
    float P11;
    float znear;
    float zfar;

    float zbuffer_width;
    float zbuffer_height;
    uint frustum_enable;
    uint backface_enable;

    uint occlusion_enable;
    uint meshlet_count;
    uint instance_count;
} cullData;

layout (binding = 8) buffer VisibilityBuffer
{
    uint visibility_data[];
};

bool checkFrustum(PerMeshletData meshlet)
{
    for (uint i = 0; i < 6; i++)
    {
        if (dot(camera.frustum[i], vec4(meshlet.center, 1)) + length(meshlet.radius) < 0.0)
        {
            return false;
        }
    }
    return true;
}

bool projectSphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb)
{
    if (-C.z < r + znear)
		return false;

	vec2 cx = C.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = C.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r);
	vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

	aabb = vec4(-minx.x / minx.y * P00, -miny.x / miny.y * P11, -maxx.x / maxx.y * P00, -maxy.x / maxy.y * P11);
	aabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f);

    return true;
}

float LinearizeDepth(float depth)
{
    return -(2.0 * cullData.zfar * cullData.znear) / (depth * (cullData.zfar - cullData.znear) - (cullData.zfar + cullData.znear));	
}

bool checkOcclusion(PerMeshletData meshlet)
{
    vec3 dir = normalize(camera.position - meshlet.center);
    vec4 sceen_space_center_last = camera.last_view_projection * vec4(meshlet.center + dir*meshlet.radius, 1.0);

    vec3 C = ((cullData.view) * vec4(meshlet.center,1.0)).xyz;

    vec4 aabb;
    if(!projectSphere(C, meshlet.radius, cullData.znear, cullData.P00, cullData.P11, aabb))
    {
        return true;
    }

    float width = (aabb.z - aabb.x) * cullData.zbuffer_width;
    float height = (aabb.w - aabb.y) * cullData.zbuffer_height;

    float mip_level = floor(log2(max(width, height)));

    vec2 uv = (aabb.xy + aabb.zw) * 0.5;
    vec2 uv0 = aabb.xy;
    vec2 uv1 = aabb.zw;
    vec2 uv2 = aabb.xw;
    vec2 uv3 = aabb.zy;

    float depth = textureLod(hiz_buffer, uv, mip_level).r;
    depth = max(depth, textureLod(hiz_buffer, uv0, mip_level).r);
    depth = max(depth, textureLod(hiz_buffer, uv1, mip_level).r);
    depth = max(depth, textureLod(hiz_buffer, uv2, mip_level).r);
    depth = max(depth, textureLod(hiz_buffer, uv3, mip_level).r);
    
    float depthSphere = abs(sceen_space_center_last.z);

    return LinearizeDepth(depth) >= depthSphere - 0.01;
}


void main()
{
	uint idx = gl_GlobalInvocationID.x;
    if (idx == 0)
	{
		atomicExchange(visible_count, 0);
		atomicExchange(invisible_count, 0);
		atomicExchange(total_count, 0);
	}

    if(idx >= cullData.meshlet_count)
    {
        return;
    }

    PerMeshletData meshlet = meshlet_data[idx];

    if(visibility_data[meshlet.instance_id] != 1)
    {
        uint dci = atomicAdd(invisible_count, 1);
        indirectDraws[cullData.meshlet_count - 1 - dci].indexCount = meshlet.index_count;
        indirectDraws[cullData.meshlet_count - 1 - dci].instanceCount = 1;
        indirectDraws[cullData.meshlet_count - 1 - dci].firstIndex = meshlet.index_offset;
        indirectDraws[cullData.meshlet_count - 1 - dci].vertexOffset = int(meshlet.vertex_offset);
        indirectDraws[cullData.meshlet_count - 1 - dci].firstInstance = 0;
        draw_data[cullData.meshlet_count - 1 - dci] = meshlet.instance_id;
        atomicAdd(total_count, 1);
        return;
    }
    
    mat4 trans = instance_data[meshlet.instance_id].world_transform * instance_data[meshlet.instance_id].pre_transform;
    meshlet.center = (trans * vec4(meshlet.center, 1.0)).xyz;
    vec3 edge = vec3(1.0) * sqrt(meshlet.radius * meshlet.radius / 3.0);
    meshlet.radius = length(vec3(
        abs(trans[0][0])*edge.x + abs(trans[0][1])*edge.y + abs(trans[0][2])*edge.z,
        abs(trans[1][0])*edge.x + abs(trans[1][1])*edge.y + abs(trans[1][2])*edge.z,
        abs(trans[2][0])*edge.x + abs(trans[2][1])*edge.y + abs(trans[2][2])*edge.z
    ));

    bool visible = true;

    if(visible && cullData.frustum_enable == 1)
    {
        visible = visible && checkFrustum(meshlet);
    }

    if(visible && cullData.backface_enable == 1)
    {
        vec3 scale = vec3(
            sqrt(trans[0][0] * trans[0][0] + trans[0][1] * trans[0][1] + trans[0][2] * trans[0][2]),
            sqrt(trans[1][0] * trans[1][0] + trans[1][1] * trans[1][1] + trans[1][2] * trans[1][2]),
            sqrt(trans[2][0] * trans[2][0] + trans[2][1] * trans[2][1] + trans[2][2] * trans[2][2])
        );

        mat3 rotation = mat3(
            trans[0].xyz/scale.x,
            trans[1].xyz/scale.y,
            trans[2].xyz/scale.z
        );

        meshlet.cone_apex = (trans * vec4(meshlet.cone_apex, 1.0)).xyz;
        meshlet.cone_axis = rotation * meshlet.cone_axis;

        visible = visible && dot(normalize(camera.position - meshlet.cone_apex), meshlet.cone_axis) < meshlet.cone_cutoff;
    }

    if(visible && cullData.occlusion_enable == 1)
    {
        visible = visible && checkOcclusion(meshlet);
    }

    if (visible)
    {
        uint dci = atomicAdd(visible_count, 1);
        indirectDraws[dci].indexCount = meshlet.index_count;
        indirectDraws[dci].instanceCount = 1;
        indirectDraws[dci].firstIndex = meshlet.index_offset;
        indirectDraws[dci].vertexOffset = int(meshlet.vertex_offset);
        indirectDraws[dci].firstInstance = 0;
        draw_data[dci] = meshlet.instance_id;
    }
    else
    {
        uint dci = atomicAdd(invisible_count, 1);
        indirectDraws[cullData.meshlet_count - 1 - dci].indexCount = meshlet.index_count;
        indirectDraws[cullData.meshlet_count - 1 - dci].instanceCount = 1;
        indirectDraws[cullData.meshlet_count - 1 - dci].firstIndex = meshlet.index_offset;
        indirectDraws[cullData.meshlet_count - 1 - dci].vertexOffset = int(meshlet.vertex_offset);
        indirectDraws[cullData.meshlet_count - 1 - dci].firstInstance = 0;
        draw_data[cullData.meshlet_count - 1 - dci] = meshlet.instance_id;
    }
    atomicAdd(total_count, 1);
}